#!/usr/bin/env bash

set -o errexit -o pipefail -o nounset

USAGE="USAGE: diff-directories <DIR1> <DIR2> [OPTIONS]"
HELP="$(cat <<EOF

Compare contents of two directories.

Options:

  For setting directory preference:

  -l, --prefer-left - prefer left directory (don't warn if files are only in left)
  -r, --prefer-right - prefer right directory (don't warn if files are only in right)
  -b, --prefer-none - (default) prefer neither directory (warn for all "only in" files)

  For squashing:

  -s, --squash - squash certain diffs for simplicity (e.g., just mention that git object directories differ, don't list)
  -f, --squash-full - full squash (including directories differing by contents)
  --no-squash - don't do any squashing (default)

  Additional output control:

  --gitignore - ignore git-ignored files
  --ignore-build - ignore build files/directories (e.g., .stack-work)
  --ignore-git - ignore .git directories
  --ignore-temp - ignore temporary/backup files
  --ignore-full - turn on all ignore options
  --no-show-changes - don't show how individual files differ (just indicate when they do)

  Other:

  -h, --help - show command help
EOF
)"

SHORT_OPTIONS=l,r,b,s,f,h
LONG_OPTIONS=prefer-left,prefer-right,prefer-none
LONG_OPTIONS+=,squash,squash-full,no-squash
LONG_OPTIONS+=,gitignore,ignore-build,ignore-git,ignore-temp,ignore-full
LONG_OPTIONS+=,no-show-changes
LONG_OPTIONS+=,help

! PARSED=$(getopt -o $SHORT_OPTIONS -l $LONG_OPTIONS --name "$0" -- "$@")

if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
  # bail e.g., if invalid arguments were passed to the command
  exit 2
fi

prefer='none'
prefer_is_set=0
set_prefer() {
  local pref="$1"
  if [ $prefer_is_set -eq 1 -a "$prefer" != "$pref" ]; then
    echo "Multiple 'prefers' flags set, but only one may be specified."
    exit 1
  fi
  prefer="$pref"
  prefer_is_set=1
}

squash='none'
squash_is_set=0
set_squash() {
  local sq="$1"
  if [ $squash_is_set -eq 1 -a "$squash" != "$sq" ]; then
    echo "Multiple 'squash' flags set, but only one may be specified."
    exit 1
  fi
  squash="$sq"
  squash_is_set=1
}

eval set -- "$PARSED"

POSITIONAL_ARGS=()

ignore_git=0
ignore_build=0
ignore_temp=0
use_gitignore=0
show_file_changes=1

while [ $# -gt 0 ]; do
  case $1 in
    -b|--prefer-none)
      set_prefer none
      shift
      ;;
    -l|--prefer-left)
      set_prefer left
      shift
      ;;
    -r|--prefer-right)
      set_prefer right
      shift
      ;;
    --no-squash)
      set_squash none
      shift
      ;;
    -s|--squash)
      set_squash squash
      shift
      ;;
    -f|--squash-full)
      set_squash full-squash
      shift
      ;;
    --gitignore)
      use_gitignore=1
      shift
      ;;
    --ignore-build)
      ignore_build=1
      shift
      ;;
    --ignore-git)
      ignore_git=1
      shift
      ;;
    --ignore-temp)
      ignore_temp=1
      shift
      ;;
    --ignore-full)
      ignore_build=1
      ignore_git=1
      ignore_temp=1
      use_gitignore=1
      shift
      ;;
    --no-show-changes)
      show_file_changes=0
      shift
      ;;
    -h|--help)
      echo "$HELP"
      exit 0
      ;;
    --)
      shift
      POSITIONAL_ARGS+=("$@")
      break
      ;;
    -*|--*)
      echo "Unknown option: $1"
      echo "$USAGE"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1")
      shift
      ;;
  esac
done
set -- "${POSITIONAL_ARGS[@]}"

if [ ${#POSITIONAL_ARGS[@]} -ne 2 ]; then
  echo "$USAGE"
  exit 1
fi

DIR1="$1"
DIR2="$2"

# quote a string for reference as a directory
quote_dir() {
  printf "%q" "$1"
}

if [ ! -d "$DIR1" ]; then
  echo "Not a directory: $(quote_dir "$DIR1")"
  exit 1
fi

if [ ! -d "$DIR2" ]; then
  echo "Not a directory: $(quote_dir "$DIR2")"
  exit 1
fi

# NOTE: squashing doesn't currently play well with 'b' option - because of the alternating Only in a, Only in b... (2022-07-10)
git_path_re='\.git[\/:]'

squash_git() {
  squash_git="$(cat <<EOF
{
  if (/^Only in /) {
    split(\$3, arr, /$git_path_re/);
    rex="^"arr[1]"$git_path_re";
    if (!(prev ~ rex)) {
      if (\$3 ~ /$git_path_re/) {
        print \$1" "\$2" "arr[1]".git/: <some git files differ>"
      } else {
        print \$0
      }
    }
    prev = \$3;
  } else {
    print \$0
    prev = \$3;
  }
}
EOF
)"
  awk "$squash_git"
}

squash_differing_directories() {
  squash_dirs="$(cat <<EOF
{
  if (/^Only in /) {
    if (\$3 == running) {
      count = count + 1
    } else {
      if (count == 1) {
        print prev_full
      } else {
        print "Only in "running" <"count" files>"
      }
      running = \$3
      count = 1
    }
    prev = \$3;
    prev_full = \$0;
  } else {
    print \$0
  }
}
END {
  if (/^Only in /) {
    if (count == 1) {
      print prev_full
    } else {
      print "Only in "running" <"count" files>"
    }
  }
}
EOF
)"

  awk "$squash_dirs"
}

IGNORES=()
add_ignores() {
  IGNORES+=("$@")
}

if [ $ignore_git -eq 1 ]; then
  add_ignores '\.git'
fi

if [ $ignore_build -eq 1 ]; then
  add_ignores '\.stack-work'
fi

if [ $ignore_temp -eq 1 ]; then
  add_ignores '\.~' '~($| )' '\.stversions'
fi

squash_verbosity() {
  if [ "$squash" = 'squash' ]; then
    squash_git
  elif [ "$squash" = 'full-squash' ]; then
    squash_git | squash_differing_directories
  else
    cat
  fi
}

normalize_dir() {
  dirname "$(find "$1" -maxdepth 0)/f"
}

# NOTE: assumes that the directory names can each only occur once in a line
simplify_naming() {
  if [ "$squash" = 'none' ]; then
    cat
  else
    awk "$(cat <<EOF
{
  curr=\$0
  d1p=index(curr, "$(normalize_dir "$DIR1")/")
  if (d1p != 0) {
    before=substr(curr, 0, d1p-1)
    after=substr(curr, d1p+length("$(normalize_dir "$DIR1")/"))
    curr=before"_dir1/"after
  }
  d2p=index(curr, "$(normalize_dir "$DIR2")/")
  if (d2p != 0) {
    before=substr(curr, 0, d2p-1)
    after=substr(curr, d2p+length("$(normalize_dir "$DIR2")/"))
    curr=before"_dir2/"after
  }
  print curr
}
EOF
)"
  fi
}

# All paths that should be git-ignored
git_ignore_paths() {
  for pd in "$(normalize_dir "$DIR1")" "$(normalize_dir "$DIR2")"; do
    for gitignore in $(find "$pd" -name .gitignore -printf "%P\n"); do
      export local gdir="$(dirname $gitignore)"
      git -C "$pd/$gdir" rev-parse 2>/dev/null
      if [ $? -ne 0 ]; then
        # not a real git directory, skip
        continue
      fi
      # only print the path below the top directory, so the file can be
      # considered for both directories in comparison
      git -C "$pd/$gdir" list-ignored | xargs -Ifile sh -c 'echo "$gdir/file"'
    done
  done
}

join_array() {
  local sep="$1"
  declare -a local arr=("${!2}")
  if [ ${#arr[@]} -eq 1 ]; then
    echo "${arr[0]}"
  else
    echo "${arr[0]}$(printf "$sep%s" "${arr[@]:1}")"
  fi
}

# All files that should be ignored in comparison
build_ignores() {
  local files=()
  if [ ${#IGNORES[@]} -eq 0 ]; then
    files=()
  else
    local ignore_re="$(join_array "|" IGNORES[@])"
    files+=("$(find "$DIR1" "$DIR2" -regextype posix-extended -regex ".*($ignore_re).*" -printf "%P\n")")
  fi
  if [ $use_gitignore -eq 1 ]; then
    files+=($(git_ignore_paths))
  fi
  if [ ${#files[@]} -eq 0 ]; then
    return
  fi
  join_array "\n" files[@] | sort | uniq
}

# path to file with paths to be ignored
ignore_file_path=/tmp/_diff_directories_ignore_paths
rm -f "$ignore_file_path"
build_ignores > "$ignore_file_path"

# With one path per line, drop any higher-precision paths once a more general
# path is found.
#
# For example, if the input is:
#
# path1/path2
# path1/path2/path3
# path1/path4
#
# Then the output would be:
#
# path1/path2
# path1/path4
strip_subsequent_higher_precision_paths() {
  awk "$(cat <<EOF
{
  if (!done1) {
    currParent=\$0
    print \$0
    done1=1
    next
  }
  lCurr=\$0
  dp=index(lCurr, currParent"/")
  if (dp != 1) {
    print lCurr
    currParent=\$0
  }
}
EOF
)"
}

tmp_files_left_path=/tmp/_diff_directories_left
tmp_files_right_path=/tmp/_diff_directories_right
tmp_files_left_path_filtered=/tmp/_diff_directories_left_filtered
tmp_files_right_path_filtered=/tmp/_diff_directories_right_filtered
diff_main() {

  # find files in each directory
  local files_in_left=("$(find "$DIR1" -printf "%P\n")")
  local files_in_right=("$(find "$DIR2" -printf "%P\n")")
  echo "$(join_array "\n" files_in_left[@])" | sort > "$tmp_files_left_path"
  echo "$(join_array "\n" files_in_right[@])" | sort > "$tmp_files_right_path"

  # filter out files that should be ignored
  echo "$(comm -23 "$tmp_files_left_path" "$ignore_file_path")" > "$tmp_files_left_path_filtered"
  echo "$(comm -23 "$tmp_files_right_path" "$ignore_file_path")" > "$tmp_files_right_path_filtered"
  local files_only_left=("$(comm -23 "$tmp_files_left_path_filtered" "$tmp_files_right_path_filtered" | strip_subsequent_higher_precision_paths)")
  local files_only_right=("$(comm -13 "$tmp_files_left_path_filtered" "$tmp_files_right_path_filtered" | strip_subsequent_higher_precision_paths)")
  local files_in_both=("$(comm -12 "$tmp_files_left_path_filtered" "$tmp_files_right_path_filtered")")

  # inform about files that are unique to either directory
  if [ $prefer != 'left' ]; then
    for only_left in ${files_only_left[@]}; do
      local full_path="$(normalize_dir "$DIR1")/$only_left"
      echo "Only in $(dirname "$full_path")/: $(basename "$full_path")"
    done
  fi
  if [ $prefer != 'right' ]; then
    for only_right in ${files_only_right[@]}; do
      local full_path="$(normalize_dir "$DIR2")/$only_right"
      echo "Only in $(dirname "$full_path")/: $(basename "$full_path")"
    done
  fi

  # diff remaining files that are in both directories
  local diff_flags=()
  if [ $show_file_changes -eq 0 ]; then
    diff_flags+=("-q")
  fi
  for shared_file in ${files_in_both[@]}; do
    if [ -f "$shared_file" ]; then
      local diffRes="$(diff ${diff_flags[@]} "$(normalize_dir "$DIR1")/$shared_file" "$(normalize_dir "$DIR2")/$shared_file")"
      if [ -n "$diffRes" ]; then
        if [ $show_file_changes -eq 1 ]; then
          echo "diff for $shared_file:"
        fi
        echo "$diffRes"
      fi
    fi
  done
}

diff_main | squash_verbosity | simplify_naming
