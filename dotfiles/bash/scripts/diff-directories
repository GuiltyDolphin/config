#!/usr/bin/env bash

set -o errexit -o pipefail -o nounset

USAGE="USAGE: diff-directories <DIR1> <DIR2> [OPTIONS]"
HELP="$(cat <<EOF

Compare contents of two directories.

Options:

  For setting directory preference:

  -l, --prefer-left - prefer left directory (don't warn if files are only in left)
  -r, --prefer-right - prefer right directory (don't warn if files are only in right)
  -b, --prefer-none - (default) prefer neither directory (warn for all "only in" files)

  For squashing:

  -s, --squash - squash certain diffs for simplicity (e.g., just mention that git object directories differ, don't list)
  -f, --squash-full - full squash (including directories differing by contents)
  --no-squash - don't do any squashing (default)

  Other:

  -h, --help - show command help
EOF
)"

SHORT_OPTIONS=l,r,b,s,f,h
LONG_OPTIONS=prefer-left,prefer-right,prefer-none
LONG_OPTIONS+=,squash,squash-full,no-squash
LONG_OPTIONS+=,help

! PARSED=$(getopt -o $SHORT_OPTIONS -l $LONG_OPTIONS --name "$0" -- "$@")

prefer='none'
prefer_is_set=0
set_prefer() {
  local pref="$1"
  if [ $prefer_is_set -eq 1 -a "$prefer" != "$pref" ]; then
    echo "Multiple 'prefers' flags set, but only one may be specified."
    exit 1
  fi
  prefer="$pref"
  prefer_is_set=1
}

squash='none'
squash_is_set=0
set_squash() {
  local sq="$1"
  if [ $squash_is_set -eq 1 -a "$squash" != "$sq" ]; then
    echo "Multiple 'squash' flags set, but only one may be specified."
    exit 1
  fi
  squash="$sq"
  squash_is_set=1
}

eval set -- "$PARSED"

POSITIONAL_ARGS=()

while [ $# -gt 0 ]; do
  case $1 in
    -b|--prefer-none)
      set_prefer none
      shift
      ;;
    -l|--prefer-left)
      set_prefer left
      shift
      ;;
    -r|--prefer-right)
      set_prefer right
      shift
      ;;
    --no-squash)
      set_squash none
      shift
      ;;
    -s|--squash)
      set_squash squash
      shift
      ;;
    -f|--squash-full)
      set_squash full-squash
      shift
      ;;
    --help|--usage)
      echo "$USAGE"
      exit 0
      ;;
    --)
      shift
      POSITIONAL_ARGS+=("$@")
      break
      ;;
    -*|--*)
      echo "Unknown option: $1"
      echo "$USAGE"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1")
      shift
      ;;
  esac
done
set -- "${POSITIONAL_ARGS[@]}"

if [ ${#POSITIONAL_ARGS[@]} -ne 2 ]; then
  echo "$USAGE"
  exit 1
fi

DIR1="$1"
DIR2="$2"

# quote a string for reference as a directory
quote_dir() {
  printf "%q" "$1"
}

if [ ! -d "$DIR1" ]; then
  echo "Not a directory: $(quote_dir "$DIR1")"
  exit 1
fi

if [ ! -d "$DIR2" ]; then
  echo "Not a directory: $(quote_dir "$DIR2")"
  exit 1
fi

filter_preference() {
  filter_re=''
  if [ "$prefer" = 'left' ]; then
    filter_re="Only in $DIR1";
  elif [ "$prefer" = 'right' ]; then
    filter_re="Only in $DIR2";
  else
    cat
    exit 0
  fi
  grep -Fv "$filter_re"
}

# NOTE: squashing doesn't currently play well with 'b' option - because of the alternating Only in a, Only in b... (2022-07-10)
git_path_re='\.git[\/:]'

squash_git() {
  squash_git="$(cat <<EOF
{
  if (/^Only in /) {
    split(\$3, arr, /$git_path_re/);
    rex="^"arr[1]"$git_path_re";
    if (!(prev ~ rex)) {
      if (\$3 ~ /$git_path_re/) {
        print \$1" "\$2" "arr[1]".git/ <some git files differ>"
      } else {
        print \$0
      }
    }
    prev = \$3;
  } else {
    print \$0
    prev = \$3;
  }
}
EOF
)"
  awk "$squash_git"
}

squash_differing_directories() {
  squash_dirs="$(cat <<EOF
{
  if (/^Only in /) {
    if (\$3 == running) {
      count = count + 1
    } else {
      if (count == 1) {
        print prev_full
      } else {
        print "Only in "running" <"count" files>"
      }
      running = \$3
      count = 1
    }
    prev = \$3;
    prev_full = \$0;
  } else {
    print \$0
  }
}
END {
  if (/^Only in /) {
    if (count == 1) {
      print prev_full
    } else {
      print "Only in "running" <"count" files>"
    }
  }
}
EOF
)"

  awk "$squash_dirs"
}

# Prefix a line with '--' to ignore/comment it out
IGNORES=$(echo "$(sed -E 's/| *--($| .*$)//gm' << EOF
    \\.stack-work
    |\\.git
    |\\.~
    |~($| )
EOF
)" | tr --delete '\n ')

git_ignore_paths() {
  find "$DIR1" "$DIR2" -name .gitignore -exec sh -c "cd \"\$(dirname {})\"; git list-ignored | xargs -Ifile echo \"\$(dirname {})/file\"" \;
}

squash_verbosity() {
  remove_ignores() {
    ignore_file=/tmp/_diff_directories_ignore_paths
    echo "$(git_ignore_paths)" > "$ignore_file"
    grep -vFf "$ignore_file"
  }
  if [ "$squash" = 'squash' ]; then
    squash_git | remove_ignores
  elif [ "$squash" = 'full-squash' ]; then
    squash_git | remove_ignores | squash_differing_directories
  else
    cat
  fi
}

# NOTE: assumes that the directory names can each only occur once in a line
simplify_naming() {
  if [ "$squash" = 'none' ]; then
    cat
  else
    awk "$(cat <<EOF
{
  curr=\$0
  d1p=index(curr, "$DIR1")
  if (d1p != 0) {
    before=substr(curr, 0, d1p-1)
    after=substr(curr, d1p+length("$DIR1"))
    curr=before"_dir1/"after
  }
  d2p=index(curr, "$DIR2")
  if (d2p != 0) {
    before=substr(curr, 0, d2p-1)
    after=substr(curr, d2p+length("$DIR2"))
    curr=before"_dir2/"after
  }
  print curr
}
EOF
)"
  fi
}

diff -r "$DIR1" "$DIR2" | filter_preference | squash_verbosity | grep -vE "$IGNORES" | simplify_naming
