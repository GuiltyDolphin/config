#+TITLE: GuiltyDolphin's Emacs Configuration
#+OPTIONS: H:10

* Emacs Configuration

** Base Configuration

*** NO FRILLS

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'inhibit-startup-screen t) ; no splash screen on start
  (tool-bar-mode -1)   ; no tool bar with icons
  (scroll-bar-mode -1) ; no scroll bars
  (menu-bar-mode -1)   ; no menu bar
#+END_SRC

*** NO JUNK

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
  (customize-set-variable 'backup-directory-alist `((".*" . ,temporary-file-directory)))
#+END_SRC

*** Other

#+BEGIN_SRC emacs-lisp
  (line-number-mode 1) ; column number in mode line
  (column-number-mode 1) ; line number in mode line

  (global-display-line-numbers-mode 1) ; line number in margin
  (global-hl-line-mode 1) ; highlight current line

  (customize-set-variable 'x-select-enable-clipboard t) ; Use the clipboard

  (display-time-mode t) ; Allow displaying of time in mode line

  (display-battery-mode 1) ; battery status in mode line

  (customize-set-variable 'indent-tabs-mode nil)
  (customize-set-variable 'standard-indent 4)
  (customize-set-variable 'tab-width 4)
  (customize-set-variable 'tab-stop-list '(4 8 12))

  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

**** User-preference variables

#+BEGIN_SRC emacs-lisp
  (defvar my-user-preferred-license "GPL-3"
    "License to use by default with some modes.")

  (customize-set-variable 'user-mail-address "software@guiltydolphin.com")
#+END_SRC

Use [[https://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] 14pt as default font.

#+BEGIN_SRC emacs-lisp
  (set-frame-font "Inconsolata-14")
#+END_SRC

I typically like fairly short lines, so we can use a default
fill column to indicate this:

#+BEGIN_SRC emacs-lisp
  (defvar my-default-fill-column
    ;; two side-by-side panes on my laptop
    62
    "Generally preferred fill column.")
#+END_SRC

*** Execution Path

#+BEGIN_SRC emacs-lisp
  (add-to-list 'exec-path "~/.cabal/bin")
#+END_SRC

*** Folder with own content

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (locate-user-emacs-file "custom"))
#+END_SRC

*** Custom functions

#+BEGIN_SRC emacs-lisp
  (defun my-find-user-init-file ()
    "Find the user's init file."
    (interactive)
    (find-file user-init-file))

  (defvar my-config-org-file
    (locate-user-emacs-file "config.org")
    "File name, including directory, of user's additional configuration file.")

  (defun my-find-user-config-file ()
    "Find config file."
    (interactive)
    (find-file my-config-org-file))

  (defun my-reload-user-init-file ()
    "Evaluate the user's init file."
    (interactive)
    (load-file user-init-file))
#+END_SRC

*** my-global-mode

Global mode for e.g., adding new global bindings without
affecting the default global settings.

#+BEGIN_SRC emacs-lisp
  (define-minor-mode my-global-mode
    "Personal configuration without changing the default global settings."
    :keymap (make-sparse-keymap))

  (define-globalized-minor-mode my-global-global-mode my-global-mode
    (lambda () (my-global-mode)))

  (my-global-global-mode)
#+END_SRC

*** Early Loaders

Packages that should be loaded early as they define
functionality used in the remainder of the config.

**** cl-lib

#+BEGIN_SRC emacs-lisp
  (use-package cl-lib)
#+END_SRC

**** bookmark

#+BEGIN_SRC emacs-lisp
  (use-package bookmark)
#+END_SRC

**** emaps

#+BEGIN_SRC emacs-lisp
  (use-package emaps
    :config
    (emaps-define-key my-global-mode-map
      (kbd "C-h K") 'emaps-describe-keymap-bindings))
#+END_SRC

*** Navigation

#+BEGIN_SRC emacs-lisp
  (defvar my-jump-init-files-map (make-sparse-keymap)
    "Keymap for jumping to init files.")

  (emaps-define-key my-jump-init-files-map
    "c" 'my-find-user-config-file
    "i" 'my-find-user-init-file)

  (defvar my-jump-map (make-sparse-keymap)
    "Keymap for jumping around.")

  (emaps-define-key my-jump-map
    "i" my-jump-init-files-map
    "p" 'evil-switch-to-windows-last-buffer
    "t" 'eshell)

  (evil-leader/set-key "g" my-jump-map)
#+END_SRC

*** Quitting Emacs

I prefer to have Emacs confirm before exiting with =C-x C-c=.

#+BEGIN_SRC emacs-lisp
  (defun my-save-buffers-kill-terminal-ask (&optional arg)
    "Prompt the user for confirmation before running `save-buffers-kill-terminal'.

  ARG gets passed to `save-buffers-kill-terminal."
    (interactive)
    (when (yes-or-no-p "Are you sure you want to quit Emacs? ")
      (save-buffers-kill-terminal arg)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (emaps-define-key my-global-mode-map
    (kbd "C-x C-c") 'my-save-buffers-kill-terminal-ask)
#+END_SRC

** Packages

** Calendar

#+BEGIN_SRC emacs-lisp
  (use-package calendar
    :config
#+END_SRC

I prefer to use ISO date formats for ease-of-use and
consistency:

#+BEGIN_SRC emacs-lisp
  (calendar-set-date-style 'iso)
#+END_SRC

*** Time & Colorscheme

#+BEGIN_SRC emacs-lisp
  (defvar my-location-name "London"
    "Name of major location for use in calendar calculations.")

  (defvar my-location-longitude [0 5 west]
    "Longitude of major location.")

  (defvar my-location-latitude [51 32 north]
    "Latitude of major location.")

  (defvar my-location-loc (list my-location-name my-location-latitude my-location-longitude)
    "Preferred location information in the form '(NAME LATITUDE LONGITUDE).")

  (require 'solar)

  (defun my-sunrise-sunset-times (loc-name loc-lat loc-lon)
    "Get the sunrise, sunset, and hours of daylight for a location.

  LOC-NAME, LOC-LAT, and LOC-LON should be the name, latitude, and longitude
  of the location for which sunrise/sunset times should be retrieved.
  They should be in a form acceptable to `calendar-location-name',
  `calendar-latitude', and `calendar-longitude' respectively.

  The result is in the form (SUNRISE SUNSET HOURS)."
    (let* ((calendar-location-name loc-name)
          (calendar-longitude loc-lon)
          (calendar-latitude loc-lat)
          (times (solar-sunrise-sunset (calendar-current-date)))
          (sunrise-time (solar-daylight (caar times)))
          (sunset-time (solar-daylight (cl-caadr times)))
          (wrap-start (format-time-string "%FT"))
          (wrap-end (format-time-string "%Z")))
      (mapcar (lambda (x) (date-to-time (concat wrap-start x wrap-end)))
              (list sunrise-time sunset-time))))

  (defun my-time-greater-p (time1 time2)
    "Return non-nil if TIME1 is later than TIME2."
    (not (or (time-less-p time1 time2) (eq time1 time2))))

  (defun my-location-sunrise-sunset (location)
    "Get the '(SUNRISE SUNSET) times for LOCATION."
    (let ((loc-name (car location))
          (loc-lat (cadr location))
          (loc-lon  (cl-caddr location)))
      (my-sunrise-sunset-times loc-name loc-lat loc-lon)))

  (defun my-date-in-daylight-hours (date)
    "Return non-nil if DATE is within the daylight hours for the current location.

  Default to NIL if daylight times cannot be retrieved."
    (let* ((sunrise-sunset (my-location-sunrise-sunset my-location-loc))
           (sunrise-time (car sunrise-sunset))
           (sunset-time (cadr sunrise-sunset))
           (curr-time (or date (current-time))))
      (and sunrise-time sunset-time
           (my-time-greater-p curr-time sunrise-time) (time-less-p curr-time sunset-time))))

  (defvar my-background-timers nil
    "Timers for changing the background mode.")

  (defun my-background-clear-timers ()
    "Clear the current background timers."
    (dolist (timer my-background-timers)
      (cancel-timer timer))
    (setq my-background-timers nil))

  (defun my-background-set (bgmode &optional timeout)
    "Set the current background mode to BGMODE.
  BGMODE should be one of 'light or 'dark.

  TIMEOUT, if non-NIL, specifies how long to wait before triggering the next
  background check."
    (set-frame-parameter nil 'background-mode bgmode)
    (set-terminal-parameter nil 'background-mode bgmode)
    (my-background-clear-timers)
    ;; give it time to sort itself out
    (let ((timeout (or timeout "2 minutes")))
      (push (run-at-time timeout nil 'my-background-initialize-timers)
            my-background-timers))
    (load-theme (if (equal bgmode 'dark) 'solarized-dark 'solarized-light) t))

  (defun my-background-set-dark (&optional timeout)
    "Set the current background mode to 'dark.

  For the meaning of TIMEOUT, see `my-background-set'."
    (interactive "sBackground timeout: ")
    (my-background-set 'dark timeout))

  (defun my-background-set-light (&optional timeout)
    "Set the current background mode to 'light.

  For the meaning of TIMEOUT, see `my-background-set'."
    (interactive "sBackground timeout: ")
    (my-background-set 'light))

  (defun my-current-background-mode ()
    "Get the current background mode (light or dark)."
    (frame-parameter nil 'background-mode))

  (defun my-background-initialize-timers ()
    "Initialise timers used to change background at the appropriate time of day."
    (let* ((sunrise-sunset (my-location-sunrise-sunset my-location-loc))
           (sunrise-time (car sunrise-sunset))
           (sunset-time (cadr sunrise-sunset))
           (current-time (current-time))
           (time-format "%F %T %Z")
           (add-bg-timer (lambda (mode time)
                           (push (run-at-time time nil (intern (format "my-background-set-%s" mode)))
                                 my-background-timers))))
    (if (my-date-in-daylight-hours current-time)
        (if (eq (my-current-background-mode) 'dark) (my-background-set-light)
          (funcall add-bg-timer 'dark sunset-time))
      (if (eq (my-current-background-mode) 'light) (my-background-set-dark)
        (let ((sunrise-today-or-next (if (time-less-p current-time sunrise-time)
                                         sunrise-time
                                       (time-add (days-to-time 1) sunrise-time)))) ; close enough
          (funcall add-bg-timer 'light sunrise-today-or-next))))))
#+END_SRC

Sometimes the background gets out of sync, so it can be useful
to manually trigger a check, for which the
=my-background-update-now= command can be used:

#+BEGIN_SRC emacs-lisp
  (defun my-background-update-now ()
    "Update the background mode according to whether the current time is in daylight or not."
    (interactive)
    (if (my-date-in-daylight-hours (current-time))
        (my-background-set-light)
      (my-background-set-dark)))
#+END_SRC

**** Color theme

#+BEGIN_SRC emacs-lisp
  (if (my-date-in-daylight-hours (current-time))
      (my-background-set-light)
    (my-background-set-dark))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** Library packages

The following packages are used as library packages, for the
APIs they expose.

*** alert

#+BEGIN_SRC emacs-lisp
  (use-package alert)
#+END_SRC

*** async
#+BEGIN_SRC emacs-lisp
  (use-package async)
#+END_SRC

*** dash

#+BEGIN_SRC emacs-lisp
  (use-package dash)
#+END_SRC

*** s

#+BEGIN_SRC emacs-lisp
  (use-package s)
#+END_SRC

*** transient

#+BEGIN_SRC emacs-lisp
  (use-package transient)
#+END_SRC

** Misc Packages

*** auto-complete

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :config
    (global-auto-complete-mode))
#+END_SRC

**** ac-slime

#+BEGIN_SRC emacs-lisp
  (use-package ac-slime
    :after (:all auto-complete slime)
    :config
    (add-hook 'slime-mode-hook #'set-up-slime-ac)
    (add-hook 'slime-repl-mode-hook #'set-up-slime-ac)
    (add-to-list 'ac-modes 'slime-repl-mode))
#+END_SRC

*** checkdoc

#+BEGIN_SRC emacs-lisp
  (use-package checkdoc
    :config
    (customize-set-variable 'checkdoc-arguments-in-order-flag nil)
    (customize-set-variable 'checkdoc-force-docstrings-flag t)
    (customize-set-variable 'checkdoc-package-keywords-flag t)
    (customize-set-variable 'checkdoc-permit-comma-termination-flag nil)
    (customize-set-variable 'checkdoc-spellcheck-documentation-flag nil)
    (customize-set-variable 'checkdoc-verb-check-experimental-flag t))
#+END_SRC

*** evil-leader

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :config
    (global-evil-leader-mode 1))

  ;; Use the space key as leader
  (evil-leader/set-leader "<SPC>")
  (evil-leader/set-key
    "ex" 'eval-expression
    "ir" 'align-regexp
    "sv" 'my-reload-user-init-file
    "ns" 'my-scratch-buffer
    "nS" 'my-new-scratch
    ","  'helm-M-x)
#+END_SRC

*** evil-local-leader

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (locate-user-emacs-file "custom/evil"))
  (use-package evil-local-leader ; Merely a modification of `evil-leader'
    :config
    (global-evil-local-leader-mode 1)
    (evil-local-leader/set-local-leader ","))

  (defvar my-lisp-modes
    '(emacs-lisp-mode lisp-interaction-mode lisp-mode slime-mode)
    "Major modes for editing Lisp files.")

  (dolist (mode my-lisp-modes)
    (evil-local-leader/set-key-for-mode mode
      "er" 'eval-region
      "eb" 'eval-buffer
      "ed" 'eval-defun))

  (evil-local-leader/set-key-for-mode 'haskell-mode
    "en" 'haskell-goto-next-error
    "eN" 'haskell-goto-prev-error
    "t"  'haskell-process-do-type
    "i"  'haskell-process-do-info
    "sd" 'inferior-haskell-send-decl)

  (evil-local-leader/set-key-for-mode 'latex-mode
    "ib" 'latex-insert-block
    "ir" 'tex-region
    "cb" 'latex-close-block)
#+END_SRC

*** evil

#+BEGIN_SRC emacs-lisp
  (defun my-kill-buffer-and-window-ask ()
    "Kill the current buffer and window if user responds in the affirmative.

  Ask again if the buffer is modified."
    (interactive)
    (when (y-or-n-p "Kill current buffer and window? ")
      (when (or
             (not (buffer-modified-p))
             (and (buffer-modified-p) (y-or-n-p "Buffer is modified, are you sure? ")))
        (kill-buffer-and-window))))

  (use-package evil
    :config
    (customize-set-variable 'evil-want-C-w-in-emacs-state t)
    ;; * and # search for full symbols.
    (customize-set-variable 'evil-symbol-word-search t)
    (evil-define-minor-mode-key '(insert replace) 'my-global-mode
      (kbd "C-c") 'evil-normal-state)
    (evil-define-minor-mode-key '(emacs insert motion normal visual) 'my-global-mode
      (kbd "C-t") evil-window-map)
    (emaps-define-key evil-window-map
      (kbd "C-h") 'previous-buffer
      (kbd "C-l") 'next-buffer
      (kbd "C-t") 'evil-window-next
      "q" 'my-save-buffers-kill-terminal-ask
      "t" 'evil-window-right ; Replaces evil-window-top-left
      "-" 'evil-window-split ; Replaces evil-window-set-width
      "|" 'evil-window-vsplit ; Replaces evil-window-decrease-height
      "x" 'my-kill-buffer-and-window-ask
      "s" 'helm-buffers-list)
    (evil-mode 1))
#+END_SRC

*** evil-surround

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+END_SRC

*** org-evil

#+BEGIN_SRC emacs-lisp
  (use-package org-evil)
#+END_SRC

*** evil-remap

#+BEGIN_SRC emacs-lisp
  (use-package evil-remap
    :config
    (evil-nnoremap! ";" 'evil-ex)
    (evil-nnoremap! ":" 'evil-repeat-find-char)
    (global-set-key (kbd "C-t") 'nil)

    (evil-vnoremap (kbd "C-c") 'evil-exit-visual-state)
    (global-set-key (kbd "C-w") 'nil)

    (evil-nnoremap! (kbd "C-u") 'evil-scroll-up)
    (evil-nnoremap! (kbd "M-u") 'universal-argument)
    ;; originally mapped to `upcase-word'
    (evil-inoremap (kbd "M-u") 'universal-argument)

    (evil-nnoremap! (kbd "Q") 'quit-window)) ; So we can *always* quit
#+END_SRC

*** Magit

#+BEGIN_SRC emacs-lisp
  (defun my-evil-set-initial-state-modes (state &rest modes)
    "Set STATE as the initial state for each of MODES.

  See `evil-set-initial-state'."
    (--map (evil-set-initial-state it state) modes))
  (put 'my-evil-set-initial-state-modes 'lisp-indent-function 'defun)

  (use-package magit
    :init
    (defvar my-evil-leader-magit-map (make-sparse-keymap)
      "Keymap for magit bindings under leader key.")
    (defvar my-magit-section-jump-map (make-sparse-keymap)
      "Keymap for jumping around magit sections.")
    (evil-leader/set-key
      "m" my-evil-leader-magit-map)
    :config
    (emaps-define-key my-evil-leader-magit-map
      "b" 'magit-show-refs-popup
      "d" 'magit-diff-working-tree
      "l" 'magit-log
      "s" 'magit-status)
    (emaps-define-key my-magit-section-jump-map
      "s" 'magit-jump-to-staged
      "u" 'magit-jump-to-unstaged
      "z" 'magit-jump-to-stashes)
    (evil-define-key '(motion normal) magit-mode-map
      (kbd "TAB") 'magit-section-toggle
      (kbd "RET") 'magit-visit-thing
      (kbd "z o") 'magit-section-show
      (kbd "z c") 'magit-section-hide
      "{" 'magit-section-backward
      "}" 'magit-section-forward)
    (evil-define-key 'visual magit-mode-map
      "s" 'magit-stage
      "u" 'magit-unstage)
    (evil-define-key 'motion magit-status-mode-map
      "g" my-magit-section-jump-map)
    (my-evil-set-initial-state-modes 'motion
      'magit-refs-mode
      'magit-status-mode
      'magit-revision-mode
      'magit-diff-mode
      'magit-log-mode
      'magit-stash-mode))

  (add-hook 'git-commit-mode-hook (lambda () (flyspell-mode t)))

  (use-package git-commit
    :config
    (customize-set-variable 'git-commit-summary-max-length 50))

  (evil-set-initial-state 'git-commit-mode 'insert)
#+END_SRC

*** man

#+BEGIN_SRC emacs-lisp
  (use-package man
    :config
    (evil-set-initial-state 'Man-mode 'motion)

    (evil-define-key 'motion Man-mode-map
      "{" 'Man-previous-section
      "}" 'Man-next-section))
#+END_SRC

*** flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config
    (global-flycheck-mode 1)
    (evil-leader/set-key
      "f" flycheck-command-map))
#+END_SRC

*** flx-ido

#+BEGIN_SRC emacs-lisp
  (use-package flx-ido
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (flx-ido-mode 1)
    (customize-set-variable 'ido-enable-flex-matching t)
    (customize-set-variable 'ido-use-faces nil))

  (emaps-define-key my-global-mode-map
    (kbd "C-h h") 'help)
  (emaps-define-key help-map
    (kbd "C-e") 'evil-scroll-line-down
    (kbd "C-y") 'evil-scroll-line-up)
#+END_SRC

*** highlighting

**** highlight-parentheses

#+BEGIN_SRC emacs-lisp
  (use-package highlight-parentheses
    :config
    (add-hook 'prog-mode-hook #'highlight-parentheses-mode))
#+END_SRC

**** rainbow-delimiters

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** rec

#+BEGIN_SRC emacs-lisp
  (use-package rec-mode)
#+END_SRC

*** swiper

#+BEGIN_SRC emacs-lisp
  (use-package swiper)
#+END_SRC

*** web-mode

#+BEGIN_SRC emacs-lisp
  (defvar my-web-mode-extensions
    (--map (format "\\.%s\\'" it)
           '("phtml" "tpl\\.php" "[agj]sp" "as[cp]x" "erb" "mustache" "djhtml" "html?"))
    "Extensions that should use 'web-mode.")

  (use-package web-mode
    :init
    (dolist (extension my-web-mode-extensions)
      (add-to-list 'auto-mode-alist (cons extension 'web-mode))))
#+END_SRC

** Email

#+BEGIN_SRC emacs-lisp
  (use-package mu4e)
#+END_SRC

** Programming Languages

*** Agda

#+BEGIN_SRC emacs-lisp
  (if (executable-find "agda-mode")
    (load-file (let ((coding-system-for-read 'utf-8))
                    (shell-command-to-string "agda-mode locate")))
    (warn "(config.org) agda-mode program is not installed, skipping agda configuration."))
#+END_SRC

*** Cask

#+BEGIN_SRC emacs-lisp
  (use-package cask-mode)
#+END_SRC

*** Erlang

#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :config
    (add-to-list 'auto-mode-alist (cons erlang-file-name-extension-regexp 'erlang-mode)))
#+END_SRC

*** Haskell

**** haskell-mode

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :config
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
    (customize-set-variable 'haskell-process-type 'stack-ghci)
    (customize-set-variable 'haskell-indent-offset 2)
    ;; This seems to have fixed the flymake issue.
    ;; Flycheck seems to handle errors well, and the
    ;; cably-repl doesn't seem to be broken.
    ;; Not sure what the issue was before.
    (add-hook 'haskell-mode-hook 'flymake-mode-off)
    (add-hook 'haskell-mode-hook 'turn-on-haskell-doc)
    (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
    (customize-set-variable 'haskell-interactive-popup-errors nil))
#+END_SRC

**** flycheck-haskell

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-haskell
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
#+END_SRC

**** shm (Structured Haskell Mode)

#+BEGIN_SRC emacs-lisp
  (use-package shm)
#+END_SRC

*** Idris

**** idris-mode

#+BEGIN_SRC emacs-lisp
  (use-package idris-mode
    :config
    (evil-local-leader/set-key-for-mode 'idris-mode
      "a" 'idris-add-clause
      "c" 'idris-case-dwim
      "l" 'idris-make-lemma
      "p" 'idris-proof-search
      "t" 'idris-type-at-point))
#+END_SRC

*** Java

**** eclim

#+BEGIN_SRC emacs-lisp
  (defvar my-software-directory (file-name-as-directory (file-truename "~/software"))
    "Directory under which custom software installations are located.")

  (defvar my-eclipse-directory (file-name-as-directory (concat my-software-directory "eclipse"))
    "Directory for eclipse installation.")

  (defun my-eclim-run-tests ()
    "Run test suite for an Eclim project using Maven."
    (interactive)
    (eclim-maven-run "test"))

  (use-package eclim
    :init
    (defvar my-eclim-find-map (make-sparse-keymap)
      "Keymap for finding things in `eclim-mode'.")
    (defvar my-eclim-refactor-map (make-sparse-keymap)
      "Keymap for refactoring in `eclim-mode'.")
    :config
    (customize-set-variable 'eclim-eclipse-dirs (list my-eclipse-directory))
    (customize-set-variable 'eclim-executable (concat my-eclipse-directory "eclim"))
    (emaps-define-key my-eclim-find-map
      "d" 'eclim-java-find-declaration
      "g" 'eclim-java-find-generic
      "r" 'eclim-java-find-references
      "t" 'eclim-java-find-type)
    (emaps-define-key my-eclim-refactor-map
      "r" 'eclim-java-refactor-rename-symbol-at-point)
    (evil-local-leader/set-key-for-mode 'java-mode
      "f" my-eclim-find-map
      "r" my-eclim-refactor-map)
    (evil-local-leader/set-key-for-mode 'java-mode
      "rt" 'my-eclim-run-tests)
    (evil-define-minor-mode-key 'motion 'eclim-mode
      "gd" 'eclim-java-find-declaration)
    (global-eclim-mode))
#+END_SRC

*** JavaScript

**** js2-mode

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode)
#+END_SRC

**** skewer-mode

#+BEGIN_SRC emacs-lisp
  (use-package skewer-mode)
#+END_SRC

*** LaTeX

**** auctex

#+BEGIN_SRC emacs-lisp
  (use-package auctex)
#+END_SRC

*** Lisp

**** eldoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config
    (global-eldoc-mode))
#+END_SRC

**** slime

#+BEGIN_SRC emacs-lisp
  (use-package slime-autoloads)
  (use-package slime
    :init
    ;; set up lisp executable for slime
    (defvar my-slime-preferred-lisp-program "sbcl"
      "Name of preferred lisp program to use with SLIME.")
    (defvar my-slime-inferior-lisp-program-variable 'inferior-lisp-program
      "Symbol `slime-mode' uses to hold the lisp program.")
    (-if-let (lisp-executable (executable-find my-slime-preferred-lisp-program))
        (eval `(setq ,my-slime-preferred-lisp-program lisp-executable))
      (warn "(init - slime) Could not find \"%s\" executable, not setting `%s'"
            my-slime-preferred-lisp-program my-slime-inferior-lisp-program-variable))
    :config
    ;; connect to SLIME whenever a lisp file is visited
    (add-hook 'slime-mode-hook
              (lambda ()
                (unless (slime-connected-p)
                  (save-excursion (slime)))))
    (slime-setup '(slime-fancy)))
#+END_SRC

*** Markdown

**** markdown-mode

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode)
#+END_SRC

***** Line Wrapping

#+BEGIN_SRC emacs-lisp
  (defvar my-markdown-fill-column
    my-default-fill-column
    "Fill column to use in `markdown-mode'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-markdown-initialise-fill-column ()
    "Initialise `auto-fill-mode' with my preferences for `markdown-mode'."
    (setq fill-column my-markdown-fill-column)
    (turn-on-auto-fill))
  (add-hook 'markdown-mode-hook 'my-markdown-initialise-fill-column)
#+END_SRC

*** OCaml

#+BEGIN_SRC emacs-lisp
  (autoload 'utop "utop" "Toplevel for OCaml" t)

  (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)

  (add-hook 'tuareg-mode-hook 'utop-minor-mode)
#+END_SRC

*** Prolog

#+BEGIN_SRC emacs-lisp
  (use-package prolog
    :config
    (customize-set-variable 'prolog-system 'swi))

  (defun my-evil-local-leader/subsume-keys-for-major-mode (major-mode)
    "Bind keys in MAJOR-MODE under `evil-local-leader' without overwriting bindings."
    (let ((major-mode-map-symbol (intern (concat (symbol-name major-mode) "-map"))))
      (when (boundp major-mode-map-symbol)
        (let ((major-mode-map (symbol-value major-mode-map-symbol))
              (local-major-bindings (evil-local-leader/bindings-for-mode major-mode)))
          (map-keymap
           (lambda (key def)
             (-if-let (key (and (characterp key) (char-to-string key)))
                 (unless (and local-major-bindings (lookup-key local-major-bindings key))
                   (evil-local-leader/set-key-for-mode major-mode key def))))
           major-mode-map)))))

  (add-hook 'after-change-major-mode-hook (lambda () (my-evil-local-leader/subsume-keys-for-major-mode major-mode)))
#+END_SRC

*** Python

#+BEGIN_SRC emacs-lisp
  (use-package python)
#+END_SRC

*** Vim Script

**** vimrc-mode

#+BEGIN_SRC emacs-lisp
  (use-package vimrc-mode)
#+END_SRC

*** YAML

**** yaml-mode

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

** Completion

*** company

#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (global-company-mode 1))
#+END_SRC

*** yasnippet

#+BEGIN_SRC emacs-lisp
  (defmacro after (mode &rest body)
    "After loading MODE, run BODY."
    (declare (indent defun))
    `(eval-after-load ,mode
       '(progn ,@body)))

  (use-package yasnippet
    :config
    (add-to-list 'yas-snippet-dirs
                 (locate-user-emacs-file "custom/snippets"))

    (add-to-list 'auto-mode-alist '("custom/snippets" . snippet-mode))
    (yas-global-mode 1)

    (emaps-define-key yas-minor-mode-map
      (kbd "C-b") 'yas-expand)

    (add-hook 'yas-before-expand-snippet-hook
              (lambda ()
                (emaps-define-key yas-minor-mode-map
                  (kbd "C-b") 'yas-next-field)))

    (add-hook 'yas-after-exit-snippet-hook
              (lambda ()
                (emaps-define-key yas-minor-mode-map
                  (kbd "C-b") 'yas-expand)))

    (add-hook 'yas-minor-mode-hook
              (lambda ()
                (yas-activate-extra-mode 'fundamental-mode)))

    (after 'yasnippet
      (yas-reload-all)
      (customize-set-variable 'yas/prompt-functions '(yas/ido-prompt yas/completing-prompt yas/no-prompt)))

    (after "yasnippet-autoloads"
      (add-hook 'prog-mode-hook 'yas-minor-mode)))
#+END_SRC

*** helm

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :init
    (defvar my-helm-leader-map (make-sparse-keymap)
      "Helm leader map.")
    (defvar my-helm-web-search-map (make-sparse-keymap)
      "Helm web search map.")
    (evil-leader/set-key "h" my-helm-leader-map)
    :config
    (emaps-define-key my-helm-leader-map
      "i" 'helm-imenu
      "o" 'helm-occur
      "s" my-helm-web-search-map)
    (customize-set-variable 'helm-google-suggest-search-url
                            "https://duckduckgo.com/?q=%s")
    (emaps-define-key my-helm-web-search-map
      "d" 'helm-google-suggest
      "w" 'helm-wikipedia-suggest)
    (evil-leader/set-key "b" 'helm-imenu)
    (evil-nnoremap! "/" 'helm-occur)
    (global-set-key (kbd "C-x C-f") 'helm-find-files)
    (helm-mode 1))
#+END_SRC

**** helm-bibtex

#+BEGIN_SRC emacs-lisp
  (use-package helm-bibtex)
#+END_SRC

*** hippie-expand

#+BEGIN_SRC emacs-lisp
  (use-package hippie-exp
    :config
    (global-unset-key (kbd "C-SPC"))
    (global-set-key (kbd "C-SPC") 'hippie-expand))
#+END_SRC

*** monitor

#+BEGIN_SRC emacs-lisp
  (use-package monitor)
#+END_SRC

*** projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :config
    (projectile-mode 1)
    (evil-leader/set-key
      "p" 'projectile-command-map)
#+END_SRC

**** Searching

I prefer to use Helm for searching projects where possible:

#+BEGIN_SRC emacs-lisp
  (defun my-projectile-git-project-p ()
    "Return t if the current project is under Git version control."
    (eq 'git (projectile-project-vcs)))

  (defmacro my-projectile-with-directory-temporarily-project (dir &rest body)
    "Execute BODY with DIR temporarily treated as the root of a project, if it doesn't already belong to one."
    (declare (indent defun))
    (let ((dir-calc (make-symbol "dir-calc")))
      `(let ((,dir-calc ,dir))
         (if (projectile-project-p ,dir-calc) (progn ,@body)
           (unwind-protect (let ((projectile-project-root ,dir-calc)) ,@body)
             (puthash (format "%s-%s" #'projectile-root-local ,dir-calc) nil projectile-project-root-cache))))))

  (defun my-projectile-grep ()
    "Grep the current project, or the current directory if not in a project.

  In a Git project this calls `helm-grep-do-git-grep',
  otherwise it uses `projectile-grep'."
    (interactive)
    (my-projectile-with-directory-temporarily-project default-directory
      (if (my-projectile-git-project-p)
          (helm-grep-do-git-grep nil)
        (projectile-grep))))

  (defun my-projectile-grep-ag ()
    "Grep the current project with AG."
    (interactive)
    (helm-do-grep-ag nil))

  (emaps-define-key projectile-command-map
    "sg" 'my-projectile-grep
    "ss" 'my-projectile-grep-ag)
#+END_SRC

To prevent files in =.gitignore= from showing up in search
results, set ~projectile-use-git-grep~:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'projectile-use-git-grep t))
#+END_SRC

** Org

*** org<<org-mode configuration>>

#+BEGIN_SRC emacs-lisp
  (defvar my-sync-directory (file-name-as-directory (file-truename "~/cloud"))
    "Directory under which files are synced with cloud.")

  (use-package org
    :init
#+END_SRC

**** Leader Bindings

Due to the use of various utilities that Org provides outside
of ~org-mode~ itself, it is useful to have a dedicated set of
bindings that you may wish to access anywhere in Emacs:

#+BEGIN_SRC emacs-lisp
  (defvar my-evil-leader-org-map (make-sparse-keymap)
    "Leader org-mode map.")

  (emaps-define-key my-evil-leader-org-map
    "a" 'org-agenda
    "c" 'org-capture
    "l" 'org-store-link
    "s" 'org-switchb)
#+END_SRC

I use a [[evil-leader][leader key]], so I find it useful to group these bindings
under that:

#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key
    "o" my-evil-leader-org-map)
#+END_SRC

**** Miscellaneous Configuration

#+BEGIN_SRC emacs-lisp
  :config
  (customize-set-variable 'org-adapt-indentation nil
                          "Don't indent node content.")

  (customize-set-variable 'org-tags-sort-function #'string-lessp
                          "Automatically sort tags lexicographically when set.")

  (customize-set-variable 'org-sort-agenda-notime-is-late nil
                          "Position timeless agenda entries before schedule for today.")
#+END_SRC

Automatically turn on spelling for org buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

**** Files

#+BEGIN_SRC emacs-lisp
  (defun my-org-subdir (path)
    "Return PATH under `org-directory'."
    (concat org-directory "/" path))

  (defvar my-org-gtd-directory (my-org-subdir "gtd")
    "Directory under which org files for GTD are kept.")

  (defun my-gtd-subdir (path)
    "Return PATH under `my-org-gtd-directory'."
    (concat my-org-gtd-directory "/" path))

  (defvar my-org-gtd-current-directory (my-gtd-subdir "current")
    "Directory under which active org files for GTD are kept.")

  (defvar my-org-gtd-calendar-directory (my-gtd-subdir "calendar")
    "Directory under which calendar org files for GTD are kept.")

  (customize-set-variable 'org-mobile-directory (concat my-sync-directory "mobile-org"))

  (customize-set-variable 'org-default-notes-file (concat org-directory "/notes.org"))
#+END_SRC

***** GTD Files

To support a GTD workflow, I use the following org files:

+ general.org :: general reference information

+ gtd.org :: active projects, actions, routines, etc.

+ inbox.org :: unprocessed items

+ maybe.org :: potential projects, ideas, etc.

+ someday.org :: inactive/potential projects, ideas, etc. that
                 I intend to engage with someday, but not now

+ tickler.org :: for remind-me-later items

#+BEGIN_SRC emacs-lisp
  (defun my-define-org-gtd-file (name dir keeps-what)
    "Define a new GTD file variable for NAME in directory DIR, containing KEEPS-WHAT items.

  KEEPS-WHAT is used to define a documentation string describing the
  variable \"Org file in which to keep KEEPS-WHAT.\".

  For example, (my-define-org-gtd-file \"test\" \"test items\")
  would result in the following variable definition:

  \(defvar my-org-gtd-test-file
    (my-org-gtd-subdir (concat name \".org\"))
    \"Org file in which to keep test items.\")"
    (eval
     `(defvar ,(intern (format "my-org-gtd-%s-file" (replace-regexp-in-string "\/" "-" name)))
        (concat ,dir "/" (concat ,name ".org"))
        ,(format "Org file in which to keep %s." keeps-what))))

  (defun my-define-org-gtd-current-file (name keeps-what)
    "See `my-define-org-gtd-file' for the meaning of NAME and KEEPS-WHAT.

  This uses `my-org-gtd-current-directory' as the parent directory."
    (my-define-org-gtd-file name my-org-gtd-current-directory keeps-what))

  (let ((gtd-files
         '(("general" . "general reference items")
           ("gtd"     . "active items")
           ("inbox"   . "unprocessed items")
           ("journal" . "a log of important events")
           ("maybe"   . "potential projects and ideas")
           ("mobile-inbox" . "unprocessed items from phone")
           ("tablet-inbox" . "unprocessed items from tablet")
           ("someday" . "inactive projects and ideas")
           ("tickler" . "tickled items"))))
    (mapc (lambda (spec)
            (-let [(name . keeps-what) spec]
              `,@(my-define-org-gtd-current-file name keeps-what)))
          gtd-files))

  (defvar my-org-gtd-inbox-files
    (list my-org-gtd-inbox-file my-org-gtd-mobile-inbox-file my-org-gtd-tablet-inbox-file)
    "List of GTD org inbox files.")
#+END_SRC

Projects are kept in the main (active) GTD file:

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-project-file my-org-gtd-gtd-file
    "Org file in which to keep active projects.")
#+END_SRC

****** Calendar Files<<Calendar File Definitions>>

There needs to be a file for storing new entries from the
calendar:

#+BEGIN_SRC emacs-lisp
  (defun my-define-org-gtd-calendar-file (name keeps-what)
    "See `my-define-org-gtd-file' for the meaning of NAME and KEEPS-WHAT.

  This uses `my-org-gtd-calendar-directory' as the parent directory."
    (my-define-org-gtd-file (concat "calendar/" name) my-org-gtd-directory keeps-what))

  (my-define-org-gtd-calendar-file "inbox" "unprocessed calendar items")
#+END_SRC

I use =calendar.org= to keep primary calendar items:

#+BEGIN_SRC emacs-lisp
  (my-define-org-gtd-calendar-file "calendar" "main calender items")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-calendar-files
    (list my-org-gtd-calendar-inbox-file
          my-org-gtd-calendar-calendar-file)
    "List of GTD org calendar files.")
#+END_SRC

**** Agenda

***** Projects

I provide variables for defining which headlines should be
considered as projects.

A project is:

+ in the projects file
+ a level two heading (see [[project-file-structure][structure of the project file]])

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-match-project
    (format "+FILE=\"%s\"&+CATEGORY=\"project\"&+LEVEL=3" (expand-file-name my-org-gtd-project-file))
    "Tags/P/T query for projects.")
#+END_SRC

Then an active project is any project which isn't marked
complete.

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-match-project-active
    (format "%s/TODO" my-org-gtd-match-project)
    "Tags/P/T query for active projects.")
#+END_SRC

****** Stuck Projects

An active project is stuck if it has no (incomplete) action
subheading.

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-stuck-projects
                          `(,my-org-gtd-match-project-active
                            ("NEXT" "WAITING") nil ""))
#+END_SRC

****** Completed Projects

A completed project is any project marked as =DONE=:

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-match-project-complete
    (format "%s/+DONE" my-org-gtd-match-project)
    "Tags/P/T query for completed projects.")
#+END_SRC

Likewise, a cancelled project is any project marked as
=CANCELLED=:

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-match-project-cancelled
    (format "%s/+CANCELLED" my-org-gtd-match-project)
    "Tags/P/T query for cancelled projects.")
#+END_SRC

***** Custom Commands and Views

#+BEGIN_SRC emacs-lisp
  (defvar my-org-super-agenda--next-action-groups
    `(org-super-agenda-groups '((:name "Deadlines" :deadline t)
                                (:name "Most Important Tasks" :tag "mit")
                                (:discard (:and (:tag "recurring" :scheduled future)))
                                (:name "@emacs" :tag "@emacs")
                                (:name "@motorbike" :tag "@motorbike")
                                (:name "@home" :tag "@home")
                                (:name "@university"  :tag "@university")
                                (:name "@errands" :tag "@errands")
                                (:name "@laptop" :tag "@laptop")
                                (:name "@phone" :tag "@phone")
                                (:name "@planning" :tag "@planning")
                                (:name "@mother" :tag "@mother")
                                (:name "Agenda - Other" :tag "@agenda")
                                (:name "@anywhere - research" :heading-regexp "^Look up")
                                (:name "@anywhere - planning" :heading-regexp "^Draft")
                                (:name "@anywhere - reading"  :tag "reading")
                                (:name "@anywhere - keyboard"  :tag "@keyboard")
                                (:name "@anywhere" :anything t)))
    "`org-super-agenda-groups' for next actions.")

  (customize-set-variable
   'org-agenda-custom-commands
   `(("A" "Agenda" agenda ""
      ((org-super-agenda-groups
        '((:name "Schedule" :time-grid t)
          (:name "Recurring Actions" :and (:tag "recurring" :todo "NEXT"))
          (:name "Recurring Reminders" :tag "recurring")
          (:name "Project Items" :category "project")))
       (org-agenda-include-deadlines nil)))
     ("C" "Calendar" agenda ""
      ((org-agenda-files ',my-org-gtd-calendar-files)))
     ("c" . "Calendar (more)")
     ("cd" "Deadlines" agenda ""
      ((org-agenda-entry-types '(:deadline))
       (org-deadline-warning-days 0)))
     ("D" "Complete"
      ((tags ,my-org-gtd-match-project-complete
             ((org-agenda-overriding-header "Completed Projects")
              (org-agenda-files '(,my-org-gtd-project-file))))
       (todo "DONE"
             ((org-agenda-overriding-header "Completed Reminders")
              (org-agenda-files '(,my-org-gtd-tickler-file))))
       (todo "DONE"
             ((org-agenda-overriding-header "Completed Inbox Items")
              (org-agenda-files ',my-org-gtd-inbox-files)))
       (tags ,my-org-gtd-match-project-cancelled
             ((org-agenda-overriding-header "Cancelled Projects")
              (org-agenda-files '(,my-org-gtd-project-file))))
       (todo "CANCELLED"
             ((org-agenda-overriding-header "Cancelled Reminders")
              (org-agenda-files '(,my-org-gtd-tickler-file))))
       (todo "CANCELLED"
             ((org-agenda-overriding-header "Cancelled Inbox Items")
              (org-agenda-files ',my-org-gtd-inbox-files)))))
     ("h" "At home" tags-todo "@home"
      ((org-agenda-overriding-header "Home")
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("i" . "Someday")
     ("ia" "Areas of Focus" tags "aof"
      ((org-agenda-overriding-header "Areas of Focus")
       (org-agenda-files '(,my-org-gtd-someday-file))
       (org-use-tag-inheritance nil)))
     ("ic" "Categories" tags "category"
      ((org-agenda-overriding-header "Categories")
       (org-agenda-files '(,my-org-gtd-someday-file))
       (org-use-tag-inheritance nil)))
     ("ip" "Potential Projects" tags-todo "CATEGORY=\"potential\"/!TODO"
      ((org-agenda-overriding-header "Potential Projects")
       (org-super-agenda-groups '((:auto-group t)))
       (org-agenda-files '(,my-org-gtd-someday-file))))
     ("I" . "Maybe")
     ("Ia" "Areas of Focus" tags "aof"
      ((org-agenda-overriding-header "Areas of Focus")
       (org-agenda-files '(,my-org-gtd-maybe-file))
       (org-use-tag-inheritance nil)))
     ("Ic" "Categories" tags "category"
      ((org-agenda-overriding-header "Categories")
       (org-agenda-files '(,my-org-gtd-maybe-file))
       (org-use-tag-inheritance nil)))
     ("Ip" "Potential Projects" tags-todo "CATEGORY=\"potential_maybe\"/!TODO"
      ((org-agenda-overriding-header "Potential Projects")
       (org-super-agenda-groups '((:auto-group t)))
       (org-agenda-files '(,my-org-gtd-maybe-file))))
     ("Ii" "Creative [I]maginings" tags-todo "CATEGORY=\"creative_imaginings\"/!TODO"
      ((org-agenda-overriding-header "Creative Imaginings")
       (org-super-agenda-groups '((:auto-group t)))
       (org-agenda-files '(,my-org-gtd-maybe-file))))
     ("n" "Actions" todo "NEXT"
      ((org-agenda-overriding-header "Next Actions")
       ,my-org-super-agenda--next-action-groups
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("N" . "Next Actions (more)")
     ("Nb" "Batch" tags-todo "batch"
      ((org-agenda-overriding-header "Batch tasks")
       (org-super-agenda-groups '((:auto-group t)))
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("Ne" "By energy" todo "NEXT"
      ((org-agenda-overriding-header "Actions by energy")
       (org-super-agenda-groups
        '((:name "Low mental, low physical"
                 :and (:tag "@energy_mental_low" :tag "@energy_physical_low"))
          (:name "Low mental, medium physical"
                 :and (:tag "@energy_mental_low" :tag "@energy_physical_medium"))
          (:name "Low mental, high physical"
                 :and (:tag "@energy_mental_low" :tag "@energy_physical_high"))
          (:name "Medium mental, low physical"
                 :and (:tag "@energy_mental_medium" :tag "@energy_physical_low"))
          (:name "Medium mental, medium physical"
                 :and (:tag "@energy_mental_medium" :tag "@energy_physical_medium"))
          (:name "Medium mental, high physical"
                 :and (:tag "@energy_mental_medium" :tag "@energy_physical_high"))
          (:name "High mental, low physical"
                 :and (:tag "@energy_mental_high" :tag "@energy_physical_low"))
          (:name "High mental, medium physical"
                 :and (:tag "@energy_mental_high" :tag "@energy_physical_medium"))
          (:name "High mental, high physical"
                 :and (:tag "@energy_mental_high" :tag "@energy_physical_high"))
          (:name "Low mental" :tag "@energy_mental_low")
          (:name "Medium mental" :tag "@energy_mental_medium")
          (:name "High mental" :tag "@energy_mental_high")
          (:name "Low physical" :tag "@energy_physical_low")
          (:name "Medium physical" :tag "@energy_physical_medium")
          (:name "High physical" :tag "@energy_physical_high")
          (:name "other" :anything t)))
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("Np" "Project actions" tags-todo "-batch&level=4&category=\"project\"/NEXT"
      ((org-agenda-overriding-header "Actions attached to projects")
       ,my-org-super-agenda--next-action-groups
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("Ns" "Standalone (no project)" tags-todo "-batch&level=3/NEXT"
      ((org-agenda-overriding-header "Standalone Actions")
       ,my-org-super-agenda--next-action-groups
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("p" "Active Projects" tags-todo "category=\"project\"/TODO"
      ((org-agenda-overriding-header "Active Projects")
       (org-super-agenda-groups '((:name "Simple Projects List" :tag "spl")
                                  (:name "Short-term Projects" :tag "short_term")
                                  (:auto-parent t)
                                  (:discard (:anything t))))
       (org-agenda-files '(,my-org-gtd-project-file))))
     ("u" "Unprocessed"
      ((tags-todo "/-DONE"
             ((org-agenda-overriding-header "Main Inboxes")
              (org-agenda-files ',my-org-gtd-inbox-files)))
       (tags "LEVEL=1"
             ((org-agenda-overriding-header "Calendar Inbox")
              (org-agenda-files '(,my-org-gtd-calendar-inbox-file))))))
     ("w" "Waiting" todo "WAITING"
      ((org-agenda-overriding-header "Waiting For")
       (org-agenda-files '(,my-org-gtd-project-file))))))
#+END_SRC

***** Files

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-agenda-files
                          `(,@my-org-gtd-calendar-files
                            ,my-org-gtd-general-file
                            ,my-org-gtd-gtd-file
                            ,@my-org-gtd-inbox-files
                            ,my-org-gtd-maybe-file
                            ,my-org-gtd-someday-file
                            ,my-org-gtd-tickler-file))
#+END_SRC

***** Following (~org-agenda-follow-mode~)

I prefer for ~org-agenda-follow-mode~ to display the tree on
its own in an indirect buffer:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-agenda-follow-indirect t)
#+END_SRC

***** Bulk Commands

The following macro facilitates acting upon headings when
performing bulk agenda commands:

#+BEGIN_SRC emacs-lisp
  (defmacro my-org-agenda-with-agenda-heading (&rest body)
    "With the current agenda heading current, execute BODY."
    (let ((marker-var (make-symbol "marker"))
          (buffer-var (make-symbol "buffer")))
      `(let* ((,marker-var (or (org-get-at-bol 'org-hd-marker)
                               (org-agenda-error)))
              (,buffer-var (marker-buffer ,marker-var)))
         (with-current-buffer ,buffer-var
           (save-excursion
             (save-restriction
               (widen)
               (goto-char ,marker-var)
               (org-back-to-heading t)
               ,@body))))))
#+END_SRC

****** Cancel and Archive

When going through old ideas, it is useful to be able to bulk
cancel and archive the items:

#+BEGIN_SRC emacs-lisp
  (defun my-org-cancel-and-archive ()
    "Achive the entry at point after setting its TODO state to CANCELLED."
    (interactive)
    (my-org-heading--set-todo "CANCELLED")
    (org-archive-subtree))

  (defun my-org-agenda--bulk-cancel-and-archive ()
    "Execute `my-org-cancel-and-archive' in the context of a bulk agenda command."
    (my-org-agenda-with-agenda-heading (my-org-cancel-and-archive)))

  (customize-set-variable 'org-agenda-bulk-custom-functions
                          '((?C my-org-agenda--bulk-cancel-and-archive)))
#+END_SRC

****** Marking

#+BEGIN_SRC emacs-lisp
  (defun my-org-agenda-bulk-mark (&optional arg)
    "Mark the entry (or ARG entries) at point for future bulk action.

  This differs from `org-agenda-bulk-mark' (which is used as the
  function's template) in that it will cause the follow buffer (see
  `org-agenda-follow-mode') to update after marking an item."
    (interactive "p")
    (dotimes (i (or arg 1))
      (unless (org-get-at-bol 'org-agenda-diary-link)
        (let* ((m (org-get-at-bol 'org-hd-marker))
         ov)
    (unless (org-agenda-bulk-marked-p)
      (unless m (user-error "Nothing to mark at point"))
      (push m org-agenda-bulk-marked-entries)
      (setq ov (make-overlay (point-at-bol) (+ 2 (point-at-bol))))
      (org-overlay-display ov (concat org-agenda-bulk-mark-char " ")
                   (org-get-todo-face "TODO")
                   'evaporate)
      (overlay-put ov 'type 'org-marked-entry-overlay))
    (org-agenda-next-line)
    (while (and (get-char-property (point) 'invisible) (not (eobp)))
      (beginning-of-line 2))
    (message "%d entries marked for bulk action"
         (length org-agenda-bulk-marked-entries))))))

  (defun my-org-agenda-bulk-unmark (&optional arg)
    "Unmark the entry at point for future bulk action.

  When ARG is non-NIL, unmark all entries.

  This differs from `org-agenda-bulk-unmark' (which is used as the
  function's template) in that it will cause the follow buffer (see
  `org-agenda-follow-mode') to update after marking an item."
    (interactive "P")
    (if arg
        (org-agenda-bulk-unmark-all)
      (cond ((org-agenda-bulk-marked-p)
         (org-agenda-bulk-remove-overlays
          (point-at-bol) (+ 2 (point-at-bol)))
         (setq org-agenda-bulk-marked-entries
           (delete (org-get-at-bol 'org-hd-marker)
               org-agenda-bulk-marked-entries))
         (org-agenda-next-line)
         (while (and (get-char-property (point) 'invisible) (not (eobp)))
           (beginning-of-line 2))
         (message "%d entries left marked for bulk action"
              (length org-agenda-bulk-marked-entries)))
        (t (message "No entry to unmark here")))))
#+END_SRC

***** Bindings

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'org-agenda-mode 'motion)

  (defvar my-org-agenda-filter-map (make-keymap)
    "Keymap for filter bindings in `org-agenda-mode'.")

  (emaps-define-key my-org-agenda-filter-map
    "/" 'helm-occur
    "^" 'org-agenda-filter-by-top-headline
    "c" 'org-agenda-filter-by-category
    "e" 'org-agenda-filter-by-effort
    "g" 'org-agenda-filter-by-regexp
    "k" 'org-agenda-filter-remove-all
    "t" 'org-agenda-filter-by-tag)

  (evil-define-key 'motion org-agenda-mode-map
    "/" my-org-agenda-filter-map
    "j" 'org-agenda-next-line
    "k" 'org-agenda-previous-line
    "m" 'my-org-agenda-bulk-mark
    "u" 'my-org-agenda-bulk-unmark
    (kbd "RET") 'org-agenda-switch-to)

  (evil-local-leader/set-key-for-mode 'org-agenda-mode
    "T" 'org-agenda-set-tags
    "r" 'org-agenda-refile
    "t" 'org-agenda-todo)
#+END_SRC

**** Refiling

Any heading explicitly tagged with =category= that is in one
of ~my-org-refile--category-files~ is assumed to be an
intended refile target.

#+BEGIN_SRC emacs-lisp
  (defvar my-org-refile--category-files
    (list
     my-org-gtd-tickler-file
     my-org-gtd-project-file
     my-org-gtd-someday-file
     my-org-gtd-general-file
     my-org-gtd-maybe-file
     my-org-gtd-calendar-calendar-file)
    "List of files to be considered for `category' tags when refiling.

  The list should be in descending preferential order (that is to say, preferred
  files for refile targets should come earlier in the list).")
#+END_SRC

The following files can be refiled to:

+ calendar/calendar.org :: for anything that should go on the
     calendar

+ general.org :: for filing reference items

+ gtd.org :: for activating items

Projects in =gtd.org= are structured as follows:<<project-file-structure>>

: Projects / Area of Focus / Project / Action

For the sake of not over-populating the refile targets, it is
assumed that only projects are being refiled (i.e., items are
refiled under an area of focus), and not actions.

+ maybe.org :: for filing items away to be considered for
               value in the future

+ someday.org :: for filing items that I wish to engage with,
                 just not now

Anything explicitly tagged with =aof= is assumed to be an
intended refile target.

+ tickler.org :: for filing items that should remain inactive
                 until a specific time in the future

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-refile-targets
                          `((,my-org-gtd-tickler-file :level . 0)
                            (,my-org-gtd-project-file :tag . "aof")
                            (,my-org-gtd-someday-file :tag . "aof")
                            (,my-org-gtd-general-file :maxlevel . 3)
                            (,my-org-gtd-maybe-file :tag . "aof")
                            (,my-org-refile--category-files :tag . "category")))
#+END_SRC

***** Completion

When refiling, it is convenient to be able to fuzzily complete
the refile location in its entirety. Changing a few Org
settings, and using helm, lets us achieve this.

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-refile-use-outline-path 'file
                          "Allow specifying refile target in a \"l1/l2/l3\" fashion.")

  (customize-set-variable 'org-outline-path-complete-in-steps nil
                          "Don't complete outline path in steps.")
#+END_SRC

***** Dealing with differing semantics in =org-capture-mode=

When ~org-capture-mode~ is active, refiling has different
semantics to when it is not, so it is useful to have a helper
command to distinguish between these two cases:

#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :config
    (defun my-org-refile-dwim (&rest args)
      "Refile the current heading.

  See `org-refile' for the meaning of ARGS.

  When `org-capture-mode' is active, this calls `org-capture-refile',
  otherwise, `org-refile' is called."
      (interactive "P")
      (if org-capture-mode
          (org-capture-refile)
        (apply #'org-refile args))))
#+END_SRC

**** Archiving

Archived entries are catalogued by datetree within files that
are grouped by year.

#+BEGIN_SRC emacs-lisp
  (customize-set-variable
   'org-archive-location
   (let ((current-year (format-time-string "%Y")))
     (format "%s_archive::datetree/"
             (f-join (my-gtd-subdir "archive") current-year "%s"))))
#+END_SRC

**** Next Action Helpers

As it is so common to create next actions, it is helpful to set
up a system for doing the following:

1. Prompting for the next action title and contexts
2. Creating a subheading with the appropriate todo keyword,
   title, and tags


Starting simply, we can define a wrapper to allow setting the
todo keyword for the current heading based on its name:

#+BEGIN_SRC emacs-lisp
  (defun my-org--get-todo-keywords ()
    "Return a list of todo keywords for the current buffer."
    (car org-todo-sets))

  (defun my-org-heading--set-todo (todo)
    "Set the todo state of the current heading to TODO."
    (org-todo (1+ (-elem-index todo (my-org--get-todo-keywords)))))
#+END_SRC

And a wrapper for inserting the correct type of subheading:

#+BEGIN_SRC emacs-lisp
  (defun my-org-heading-insert-subheading-respect-content ()
    "Like `org-insert-subheading', but insert the heading after current tree."
    (interactive)
    (org-insert-subheading '(4)))
#+END_SRC

To allow completing multiple tags, a new completion function
needs to be defined.

The following function is inspired by
~helm-org-completing-read-tags~, which was promising, but
(rather unfortunately) over complicates and restricts the
ability to match on tags (at the time, it was hard-coded to
only work when the prompt was the (exact) string ~"Tags: "~).

#+BEGIN_SRC emacs-lisp
  (defun my-org--completing-read-tags
      (prompt &optional tags predicate require-match
              initial-input hist
              def inherit-input-method)
    "Read a list of tags from the minibuffer, with completion.

  If TAGS is supplied, it should be a list of tags to complete,
  otherwise, `org-last-tags-completion-table' is used instead.

  The remaining arguments are the same as for `completing-read'."
    (let ((crm-separator ":\\|,\\|\\s-")
          (table (mapcar 'car (or tags org-last-tags-completion-table))))
      (org-uniquify
       (completing-read-multiple prompt table predicate
                                 require-match initial-input
                                 hist def inherit-input-method))))
#+END_SRC

Now some helpers for retrieving the available contexts:

#+BEGIN_SRC emacs-lisp
  (defun my-org--get-agenda-tags-list ()
    "Return a list of all known agenda tags."
    (org-global-tags-completion-table
     (org-agenda-files)))

  (defun my-org-gtd--get-contexts ()
    "Return a list of known context tags."
    (--filter (string-match-p "^@" (car it)) (my-org--get-agenda-tags-list)))
#+END_SRC

And finally we can define the desired functions for creating
action headings:

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd--next-action-todo-keyword "NEXT"
    "Todo keyword to indicate next actions.")

  (defun my-org-gtd--prompt-next-action-energies ()
    "Prompt or physical and mental energies, and return them as tags."
    (let ((energy-prompt
           (lambda (energy-type)
             (let ((energy (completing-read (format "%s energy [enter to skip]: " energy-type) '(unknown low medium high) nil t)))
               (when (not (equal "unknown" energy)) (format "@energy_%s_%s" energy-type energy))))))
      (let ((physical-energy (funcall energy-prompt "physical"))
            (mental-energy (funcall energy-prompt "mental")))
        (-non-nil (list physical-energy mental-energy)))))

  (defun my-org-gtd--prompt-next-action-title-context ()
    "Prompt for the title and contexts for a next action."
    (let ((org-add-colon-after-tag-completion t))
      (let* ((title (read-string "Action: "))
            (context-tags (my-org--completing-read-tags "Context: " (my-org-gtd--get-contexts)))
            (tags (-concat context-tags (my-org-gtd--prompt-next-action-energies))))
        (list title tags))))

  (defun my-org-gtd-insert-next-action-heading (text tags)
    "Insert TEXT as a new action heading below the current heading.

  TAGS specifies a list of tags to apply to the heading."
    (interactive (my-org-gtd--prompt-next-action-title-context))
    (save-excursion
      (org-end-of-line)
      (my-org-heading-insert-subheading-respect-content)
      (insert text)
      (my-org-heading--set-todo my-org-gtd--next-action-todo-keyword)
      (org-set-tags (-cons* "next_action" tags))))
#+END_SRC

Additionally, it is useful to have a helper for creating
"Waiting for" headings.

Waiting for headings request a reminder time at which to be
re-evaluated.

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd--waiting-for-todo-keyword "WAITING"
    "Todo keyword to indicate waiting fors.")

  (defun my-org-gtd--prompt-waiting-for ()
    "Prompt for information for building a waiting for heading."
    (let ((wf-what (read-string "Waiting for what: "))
          (remind-date (org-read-date nil nil nil "Reminder: ")))
      (list wf-what remind-date)))

  (defun my-org-gtd-insert-waiting-for-heading (text remind-date)
    "Insert TEXT as a new waiting heading below the current heading.

  REMIND-DATE specifies the date at which to re-evaluate the waiting for."
    (interactive (my-org-gtd--prompt-waiting-for))
    (save-excursion
      (let ((wf-header (format "Waiting for %s" text)))
        (org-end-of-line)
        (my-org-heading-insert-subheading-respect-content)
        (insert wf-header)
        (my-org-heading--set-todo my-org-gtd--waiting-for-todo-keyword)
        (org-schedule nil remind-date))))
#+END_SRC

**** Todo and Capture

***** Todo Keywords

#+BEGIN_SRC emacs-lisp
  (customize-set-variable
   'org-todo-keywords
   '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|"
               "DONE(d)" "CANCELLED(c)")))
#+END_SRC

***** Capture Templates

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        `(("t" "Inbox" entry (file ,my-org-gtd-inbox-file)
           "* TODO %?\n:PROPERTIES:\n:CREATED:  %U\n:END:")
          ("e" "Calendar")
          ("ed" "Event (single day)" entry (file ,my-org-gtd-calendar-inbox-file)
           "* %^{Title}%?\n%^{Date}t")
          ("et" "Event (range)" entry (file ,my-org-gtd-calendar-inbox-file)
           "* %^{Title}%?\n%^{Start}t--%^{End}t")
          ("j" "Journal" entry (file+olp+datetree ,my-org-gtd-journal-file)
           "* %? %^G\n:PROPERTIES:\n:CREATED:  %U\n:END:\n%i")))
#+END_SRC

**** Bindings

***** Navigation

I find that ~helm-org-in-buffer-headings~ (with
~helm-org-format-outline-path~ set to ~t~) provides a better
alternative to ~helm-imenu~ when in Org:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'helm-org-format-outline-path t
                          "Show all org levels as a path.")

  (evil-leader/set-key-for-mode 'org-mode
    "b" 'helm-org-in-buffer-headings)
#+END_SRC

***** Other Bindings

#+BEGIN_SRC emacs-lisp
  (defvar my-org-gtd-new-map (make-keymap)
    "Keymap for creating new things in (GTD) `org-mode'.")

  (emaps-define-key my-org-gtd-new-map
    "a" 'my-org-gtd-insert-next-action-heading
    "w" 'my-org-gtd-insert-waiting-for-heading)

  (evil-local-leader/set-key-for-mode 'org-mode
    "T" 'org-set-tags-command
    "e" 'org-edit-special
    "n" my-org-gtd-new-map
    "r" 'my-org-refile-dwim
    "t" 'org-todo)
#+END_SRC

**** Source Blocks

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-src-fontify-natively t)

  (customize-set-variable
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t))))
#+END_SRC

*** org-super-agenda

#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :config

    ;; these re-mappings fix an issue where being on a heading
    ;; with org-super-agenda mode enabled would cause j and k to
    ;; behave differently to desired
    (emaps-define-key org-super-agenda-header-map
      ;; previously org-agenda-goto-date
      "j" 'org-agenda-next-line
      ;; previously org-agenda-capture
      "k" 'org-agenda-previous-line)

    (org-super-agenda-mode 1))
#+END_SRC

*** org-brain

#+BEGIN_SRC emacs-lisp
  (use-package org-brain
    ;; :after doesn't seem to work... Perhaps because org is builtin?
    ;; so I'm having to place 'org-brain physically after 'org
    :after (:all evil org)
    :init
#+END_SRC

**** Bindings

I want quick access to ~org-brain-visualize~ from anywhere:

#+BEGIN_SRC emacs-lisp
  (emaps-define-key my-evil-leader-org-map
    "b" 'org-brain-visualize)
#+END_SRC

Additionally, within =org-brain= I find it useful to be able
to access ~org-brain-visualze~ quickly via the leader key:

#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key-for-mode 'org-brain-visualize-mode
    "b" 'org-brain-visualize)
#+END_SRC

Some bindings are kept under the local leader key, as with
[[org-mode configuration][org-mode]].

~org-brain-archive~ doesn't request explicit confirmation
before archiving, so I define a wrapper:

#+BEGIN_SRC emacs-lisp
  (defun my-org-brain-archive-with-confirmation (entry)
    "Use `org-brain-archive' on ENTRY after confirmation from the user."
    (interactive (list (org-brain-entry-at-pt)))
    (when (yes-or-no-p "Archive the current entry? ")
      (org-brain-archive entry)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (evil-local-leader/set-key-for-mode 'org-brain-visualize-mode
    "T" 'org-brain-set-tags
    "a" 'my-org-brain-archive-with-confirmation
    "m" 'org-brain-visualize-mind-map
    "p" 'org-brain-pin)
#+END_SRC

I use evil's =motion= state, with heavy binding customisation,
for ~org-brain-visualize-mode~:

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'org-brain-visualize-mode 'motion)
#+END_SRC

***** Creation Commands

For adding resources, I find that
~org-brain-visualize-paste-resource~ doesn't work quite how I
want it, so I've defined some helpers to give a more expected
behaviour:

#+BEGIN_SRC emacs-lisp
  (defun my-org--completing-read-link (&optional default)
    "Read a stored link from the minibuffer.

  DEFAULT, if non-nil, specifies the default link to use."
    (let* ((stored-links (mapcar #'car org-stored-links))
           (first-link (car stored-links))
           (hist-var (make-symbol "link-history")))
      (eval
       `(let ((,hist-var (append stored-links org-insert-link-history)))
          (org-completing-read
           "Link: " stored-links nil nil nil ',hist-var (or default first-link))))))

  (defun my-org--try-get-link-description (link)
    "Return a suitable description for LINK, if one can be found."
    (nth 1 (assoc link org-stored-links)))

  (defun my-org-cliplink--retrieve-title (url)
    "Retrieve the title for URL using `org-cliplink-retrieve-title-synchronously'.

  This deals with some errors and edge cases."
    (condition-case nil
        (shut-up (org-cliplink-retrieve-title-synchronously url))
      (error nil)))

  (defun my-org-brain--paste-resource ()
    "Prompt for a resource and add it as a resource link.

  See `org-brain-add-resource'."
    (interactive)
    (-when-let (link (my-org--completing-read-link
                      ;; only use the clipboard contents if it resembles
                      ;; some kind of link
                      (let ((cliplink (org-cliplink-clipboard-content)))
                        (when (url-type (url-generic-parse-url cliplink))
                          cliplink))))
      (let ((description
             (read-string "Description: "
                          (or (my-org--try-get-link-description link)
                              (my-org-cliplink--retrieve-title link)))))
        (org-brain-add-resource link description))))
#+END_SRC

Command for prompting for and inserting links (with
descriptions):

#+BEGIN_SRC emacs-lisp
  (defun my-org--insert-link ()
    "Prompt for a link and add insert it with a description."
    (interactive)
    (-when-let (link (my-org--completing-read-link
                      ;; only use the clipboard contents if it resembles
                      ;; some kind of link
                      (let ((cliplink (org-cliplink-clipboard-content)))
                        (when (url-type (url-generic-parse-url cliplink))
                          cliplink))))
      (let ((default-description
              (or (my-org--try-get-link-description link)
                  (my-org-cliplink--retrieve-title link))))
        (org-insert-link nil link default-description))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar my-org-brain-creation-map (make-sparse-keymap)
    "Keymap for creation bindings in `org-brain-visualize-mode'.")

  (emaps-define-key my-org-brain-creation-map
    "c" 'org-brain-add-child
    "f" 'org-brain-add-friendship
    "h" 'org-brain-new-child
    "p" 'org-brain-add-parent
    "r" 'my-org-brain--paste-resource)
#+END_SRC

***** Deletion Commands

#+BEGIN_SRC emacs-lisp
  (defvar my-org-brain-deletion-map (make-sparse-keymap)
    "Keymap for deletion bindings in `org-brain-visualize-mode'.")

  (emaps-define-key my-org-brain-deletion-map
    "c" 'org-brain-remove-child
    "d" 'org-brain-delete-entry
    "f" 'org-brain-remove-friendship
    "p" 'org-brain-remove-parent)
#+END_SRC

***** Visualisation Commands

#+BEGIN_SRC emacs-lisp
  (defvar my-org-brain-visualisation-map (make-keymap)
    "Keymap for visualisation commands in `org-brain-visualize-mode'.")

  (emaps-define-key my-org-brain-visualisation-map
    "P" 'org-brain-hide-ancestor-level
    "c" 'org-brain-hide-descendant-level
    "o" 'org-brain-show-descendant-level
    "p" 'org-brain-show-ancestor-level)
#+END_SRC

***** Top-level Bindings

#+BEGIN_SRC emacs-lisp
  :config
  (evil-define-key 'motion org-brain-visualize-mode-map
    "D" 'org-brain-delete-entry
    "a" my-org-brain-creation-map
    "d" my-org-brain-deletion-map
    "j" 'forward-button
    "k" 'backward-button
    "o" 'org-brain-new-child
    "q" 'org-brain-visualize-quit
    "v" 'org-brain-visualize
    "z" my-org-brain-visualisation-map
    (kbd "C-o") 'org-brain-visualize-back)
#+END_SRC

***** Navigation

I find it convenient to be able to jump to the pinned items:

#+BEGIN_SRC emacs-lisp
  (defun my-org-brain-jump-to-pinned ()
    "Jump to the button for the first pinned item."
    (interactive)
    (goto-char (point-min))
    (re-search-forward "^PINNED:")
    (forward-button 1))

  (evil-define-key 'motion org-brain-visualize-mode-map
    "gp" 'my-org-brain-jump-to-pinned)
#+END_SRC

Likewise for the history:

#+BEGIN_SRC emacs-lisp
  (defun my-org-brain-jump-to-history ()
    "Jump to the button for the first history item."
    (interactive)
    (goto-char (point-min))
    (re-search-forward "^HISTORY:")
    (forward-button 1))

  (evil-define-key 'motion org-brain-visualize-mode-map
    "gh" 'my-org-brain-jump-to-history)
#+END_SRC

And friends:

#+BEGIN_SRC emacs-lisp
  (defun my-org-brain-jump-to-friends ()
    "Jump to the button for the first friend item."
    (interactive)
    (if org-brain-visualizing-mind-map
        (progn
          (goto-char (point-min))
          (re-search-forward "^FRIENDS:")
          (forward-button 1))
      (user-error "Jump to friends only available when visualizing as a mind-map")))

  (evil-define-key 'motion org-brain-visualize-mode-map
    "gf" 'my-org-brain-jump-to-friends)
#+END_SRC

**** Misc Configuration

#+BEGIN_SRC emacs-lisp
  (customize-set-variable
   'org-id-track-globally t
   "Track IDs through files.")

  (add-to-list
   'org-capture-templates
   '("b" "Brain" plain (function org-brain-goto-end)
     "* %i%?" :empty-lines 1))
#+END_SRC

I have two brains, a personal one, and an academic one. I
provide convenient bindings for switching between the two
brains.

#+BEGIN_SRC emacs-lisp
  (defvar my-org-brain-academic-brain-path (my-org-subdir "org-brain/academic")
    "Path to my academic org brain.")

  (defvar my-org-brain-personal-brain-path (my-org-subdir "org-brain/personal")
    "Path to my personal org brain.")

  (defun my-org-brain-switch-to-academic-brain ()
    "Switch to my academic org brain."
    (interactive)
    (org-brain-switch-brain my-org-brain-academic-brain-path))

  (defun my-org-brain-switch-to-personal-brain ()
    "Switch to my personal org brain."
    (interactive)
    (org-brain-switch-brain my-org-brain-personal-brain-path))

  (transient-define-prefix my-org-brain-brain-selection ()
    "Transient for selecting an org brain."
    ["Select Brain"
     ("a" "Academic" my-org-brain-switch-to-academic-brain)
     ("p" "Personal" my-org-brain-switch-to-personal-brain)])

  (emaps-define-key my-evil-leader-org-map
    "B" 'my-org-brain-brain-selection)
#+END_SRC

I store my brains in my usual org directory (defaulting to my
academic brain):

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-brain-path my-org-brain-academic-brain-path)
#+END_SRC

I usually want all file and headline entries to be presented as
choices when using ~org-brain-visualize~:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-brain-visualize-default-choices 'all)
#+END_SRC

I prefer the entire entry title to always be displayed:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'org-brain-title-max-length 0))
#+END_SRC

*** org-cliplink

#+BEGIN_SRC emacs-lisp
  (use-package org-cliplink
    :config
    (customize-set-variable 'org-cliplink-max-length 500))
#+END_SRC

*** org-ref

#+BEGIN_SRC emacs-lisp
  (use-package org-ref)
#+END_SRC

*** Line Wrapping

#+BEGIN_SRC emacs-lisp
  (defvar my-org-fill-column
    my-default-fill-column
    "Fill column to use in `org-mode'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-org-initialise-fill-column ()
    "Initialise `auto-fill-mode' with my preferences for `org-mode'."
    (setq fill-column my-org-fill-column)
    (turn-on-auto-fill))
  (add-hook 'org-mode-hook 'my-org-initialise-fill-column)
#+END_SRC

*** Calendar

**** Calendar URLs

Until I find a better alternative, I use the following for
formatting URL paths:

#+BEGIN_SRC emacs-lisp
  (defun my-url-path-join (path &rest paths)
    "Join PATH with PATHS as a URL."
    (s-join "/" (cons path paths)))
#+END_SRC

=org-caldav= requires that we provide it with a calendar URL,
the following function can do this for Nextcloud calendars:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar-nextcloud-calendars-url (server user)
    "Return the URL for calendars stored in SERVER for USER.

  SERVER should not end with a trailing slash."
    (my-url-path-join server "remote.php/dav/calendars" user))
#+END_SRC

I use environment variables to store personal information about
the calendars:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar--get-environment (varname)
    "Return the value of the calendar environment variable ending with VARNAME."
    (getenv (format "PERSONAL_CALENDAR_%s" varname)))

  (defun my-calendar-get-calendar-id ()
    "Return the personalised main calendar ID."
    (my-calendar--get-environment "CALENDAR_ID"))
#+END_SRC

Which allows the definition of helpers to resolve the desired
user calendar URLs:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar-nextcloud-get-personalised-calendars-url ()
    "Return the personalised Nextcloud URL for calendars."
    (let ((server (my-calendar--get-environment "SERVER"))
          (userid (my-calendar--get-environment "USER_ID")))
      (and server userid (my-calendar-nextcloud-calendars-url server userid))))

  (defun my-calendar-nextcloud-get-personalised-calendar-url ()
    "Return the personalised Nextcloud URL for main calendar."
    (let ((calendars-url (my-calendar-nextcloud-get-personalised-calendars-url))
          (calendar-id (my-calendar-get-calendar-id)))
      (and calendars-url calendar-id (my-url-path-join calendars-url calendar-id))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-calendar-url--configure ()
    "Configure `org-caldav' calendar URLs."
    (customize-set-variable 'org-caldav-url (my-calendar-nextcloud-get-personalised-calendars-url))
    (customize-set-variable 'org-caldav-calendar-id (my-calendar-get-calendar-id)))
#+END_SRC

**** org-caldav

I use =org-caldav= for syncing calendars.

There's no point in loading =org-caldav= if a calendar URL
cannot be generated, but the user should be warned that this is
the case:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar--can-retrieve-calendar-url-or-warn ()
    "Return t if a calendar URL can be formed, warn otherwise."
    (or (my-calendar-nextcloud-get-personalised-calendar-url)
        (and (warn (concat "my-calendar: could not retrieve calendar URL, "
                           "please make sure all environment variables are initialised "
                           "(see `my-calendar--get-environment' for more information)"))
             nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-caldav
    :if (my-calendar--can-retrieve-calendar-url-or-warn)
    :init
#+END_SRC

***** Calendar Files

See [[Calendar File Definitions]] for the definitions of calendar files.

Some variables must be customised for =org-caldav= to recognise
the calendars and their files:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar-files--configure ()
    "Configure `org-caldav' calendar files."
    (customize-set-variable 'org-caldav-inbox my-org-gtd-calendar-inbox-file)
    (customize-set-variable 'org-caldav-files my-org-gtd-calendar-files))
#+END_SRC

***** Asynchronous Syncing

I have a separate [[elisp:(org-open-link-from-string%20(format%20"file:%25s"%20(executable-find%20"sync-calendar")))][sync-calendar]] command for syncing the
calendar with ~org-caldav-sync~, this can then be run
asynchronously inside Emacs:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar-sync--get-log-buffer ()
    "Initialise the calendar sync log buffer."
    (with-current-buffer (get-buffer-create "*calendar sync log*")
      (setq buffer-read-only t)
      (current-buffer)))

  (defvar my-calendar-sync--process-name "calendar sync"
    "Name used for calendar sync process.")

  (defun my-calendar-sync--log (msg)
    "Log MSG to the `my-calendar-sync--log-buffer' buffer with a timestamp."
    (with-current-buffer (my-calendar-sync--get-log-buffer)
      (let ((buffer-read-only nil))
        (with-buffer-modified-unmodified
         (goto-char (point-max))
         (insert (format "[%s] %s\n" (format-time-string "%FT%T%z") msg))))))

  (defun my-calendar-sync--log-with-warn (msg &optional time)
    "Log MSG as with `my-calendar-sync--log', but additionally emit a warning.

  Optionally, TIME may be specified to indicate the timestamp to be used when
  logging. If TIME is not specified, the current time is used instead."
    (warn (format "%s: [%s]: %s"
                  my-calendar-sync--process-name
                  (format-time-string "%FT%T" time)
                  msg))
    (my-calendar-sync--log msg))

  (defun my-calendar-sync--sync-in-progress ()
    "Return t if a calendar sync is in progress."
    (--any (eq (process-name it)
               my-calendar-sync--process-name)
           (process-list)))

  (defun my-calendar-sync-in-background ()
    "Sync calendars in the background."
    (interactive)
    (my-calendar-sync--log "sync started")
    (if (my-calendar-sync--sync-in-progress)
        (my-calendar-sync--log-with-warn "sync aborted: sync already in progress")
      (if (--any (-when-let (cbuffer (get-file-buffer it)) (buffer-modified-p cbuffer))
                 org-caldav-files)
          (my-calendar-sync--log-with-warn "sync aborted: some calendar files are modified")
        (async-start-process my-calendar-sync--process-name "sync-calendar"
                             (lambda (proc)
                               (if (eq (process-exit-status proc) 0)
                                   (progn
                                     (my-calendar-sync--log "sync complete")
                                     (let ((temp-buffer-show-function (lambda (buffer))))
                                       (with-output-to-temp-buffer "*calendar sync result*"
                                         (princ (buffer-string)))))
                                 (my-calendar-sync--log-with-warn "sync failed")))))))
#+END_SRC

Calendars should be synced every ten minutes:

#+BEGIN_SRC emacs-lisp
  (defvar my-calendar-sync-interval 600
    "Number of seconds to wait between calendar syncs.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar my-calendar--sync-timer nil
    "Timer for syncing calendars.")

  (defun my-calendar-sync--initialise-timers ()
    "Initialise timers necessary for syncing the calendars."
    (when (timerp my-calendar--sync-timer)
      (cancel-timer my-calendar--sync-timer))
    (setq my-calendar--sync-timer
          (run-at-time 0 my-calendar-sync-interval 'my-calendar-sync-in-background)))
#+END_SRC

And all we need to do when configuring is set up the timers:

#+BEGIN_SRC emacs-lisp
  (defun my-calendar-sync--configure ()
    "Configure background syncing for calendars."
    (unless noninteractive
      (my-calendar-sync--initialise-timers)))
#+END_SRC

***** ~:config~ section

#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

+ configure the calendar URLs:

#+BEGIN_SRC emacs-lisp
  (my-calendar-url--configure)
#+END_SRC

+ configure the calendar files:

#+BEGIN_SRC emacs-lisp
  (my-calendar-files--configure)
#+END_SRC

+ configure background syncing:

#+BEGIN_SRC emacs-lisp
  (my-calendar-sync--configure))
#+END_SRC

*** comint

#+BEGIN_SRC emacs-lisp
  (use-package comint
    :config
    (evil-define-key '(motion normal) comint-mode-map
      (kbd "C-d") 'evil-scroll-down))
#+END_SRC

*** org-reveal

#+BEGIN_SRC emacs-lisp
  (defvar my-slide-directory
    (concat my-sync-directory "Documents/slides/")
    "Location of main slide directory.")

  (use-package org-re-reveal
    :config
    (customize-set-variable 'org-re-reveal-root (concat my-slide-directory "reveal.js")))
#+END_SRC

** TeX

#+BEGIN_SRC emacs-lisp
  (defvar my-latex-fill-column
    ;; two side-by-side panes on my laptop
    my-default-fill-column
    "Fill column to use in `latex-mode'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-latex-initialise-fill-column ()
    "Initialise `auto-fill-mode' with my preferences for `latex-mode'."
    (setq fill-column my-latex-fill-column)
    (turn-on-auto-fill))
  (add-hook 'latex-mode-hook 'my-latex-initialise-fill-column)
  (add-hook 'LaTeX-mode-hook 'my-latex-initialise-fill-column)
#+END_SRC

** Other commands

#+BEGIN_SRC emacs-lisp
  (defun my-scratch-buffer ()
    "Switch to the *scratch* buffer, making a new one if necessary."
    (interactive)
    (switch-to-buffer "*scratch*"))

  (defun my-clear-buffer (&optional buffer)
    "Clear all the text in BUFFER without modifying the kill ring."
    (interactive "b")
    (let ((buffer (or buffer (current-buffer))))
         (with-current-buffer buffer
              (kill-region (point-min) (point-max)))))

  (defun my-new-scratch ()
    "Open a clean *scratch* buffer.

  If a *scratch* buffer exists, this will undo any changes made in that buffer."
    (interactive)
    (my-scratch-buffer)
    (my-clear-buffer))

  (global-unset-key (kbd "C-s"))

  (defvar my-state-switch-map (make-sparse-keymap)
    "Map for switching evil states.")
  (emaps-define-key my-state-switch-map
    "n" 'evil-normal-state
    "m" 'evil-motion-state
    "e" 'evil-emacs-state)

  (emaps-define-key my-global-mode-map (kbd "C-s") my-state-switch-map)
#+END_SRC

*** spelling

#+BEGIN_SRC emacs-lisp
  (use-package flyspell)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'Custom-mode 'normal)
  (evil-set-initial-state 'finder-mode 'motion)
#+END_SRC

*** irc

#+BEGIN_SRC emacs-lisp
  (use-package rcirc
    :init
    (defvar my-rcirc-cmd-list-map (make-sparse-keymap)
      "Keymap for rcirc listing commands.")

    (emaps-define-key my-rcirc-cmd-list-map
      "n" 'rcirc-cmd-names)

    (evil-local-leader/set-key-for-mode 'rcirc-mode
      "j" 'rcirc-cmd-join
      "m" 'rcirc-cmd-msg
      "n" 'rcirc-cmd-nick
      "l" my-rcirc-cmd-list-map)

    (evil-set-initial-state 'rcirc-mode 'normal)

    :config
    (customize-set-variable 'rcirc-log-flag t "log IRC messages")
    (customize-set-variable 'rcirc-default-nick "GuiltyDolphin"))
#+END_SRC

*** cperl

#+BEGIN_SRC emacs-lisp
  (use-package cperl-mode
    :init
    (defalias 'perl-mode 'cperl-mode)
    :config
    (customize-set-variable 'cperl-indent-level 4)
    (customize-set-variable
     'cperl-close-paren-offset (- cperl-indent-level))
    (customize-set-variable
     'cperl-continued-statement-offset cperl-indent-level)
    (customize-set-variable 'cperl-indent-parens-as-block t
                            "Ensure nice indentation after parens."))
#+END_SRC

*** Search

[[https://duckduckgo.com][DuckDuckGo]] is a search engine that respects users' privacy.

#+BEGIN_SRC emacs-lisp
  (defun my-search-duckduckgo (query)
    "Search DuckDuckGo for QUERY."
    (interactive "sEnter query: ")
    (browse-url (format "https://duckduckgo.com/html?q=%s"
                        (url-hexify-string query))))

  (defun my-search-duckduckgo-site (site query)
    "Use DuckDuckGo to search SITE for QUERY."
    (interactive "sEnter site: \nsEnter query: ")
    (my-search-duckduckgo (format "%s site:%s" query site)))
#+END_SRC

I find it useful to have a quick way to search the [[https://forum.gettingthingsdone.com][Getting
Things Done Forums]].

#+BEGIN_SRC emacs-lisp
  (defun my-search-gtd-forum (query)
    "Search the Getting Things Done forums for QUERY."
    (interactive "sEnter query: ")
    (my-search-duckduckgo-site "forum.gettingthingsdone.com" query))
#+END_SRC

** Other Config

*** Helpers

#+BEGIN_SRC emacs-lisp
  (defun my-java-args-to-param-doc-list (text)
    "Identify a list of Java parameters from TEXT."
    (let ((params (split-string text ",")))
      (--filter it (--map (progn (string-match "\\w+ \\(\\w+\\)$" it) (ignore-errors (match-string 1 it))) params))))

  (defun my-move-key (keymap-from keymap-to key)
    "Move a keybinding from KEYMAP-FROM to KEYMAP-TO.

  KEY is the binding to be moved.

  This removes the binding from KEYMAP-FROM."
    (emaps-define-key keymap-to key (lookup-key keymap-from key))
    (emaps-define-key keymap-from key nil))

  (my-move-key evil-motion-state-map evil-normal-state-map " ")
#+END_SRC
